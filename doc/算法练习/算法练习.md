# 算法分析

---

## 1 两数之和

### 1.1 算法要求

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

你可以按任意顺序返回答案。

1. 示例 1：

   输入：nums = [2,7,11,15], target = 9

   输出：[0,1]

   解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

2. 示例 2：

   输入：nums = [3,2,4], target = 6

   输出：[1,2]

3. 示例 3：

   输入：nums = [3,3], target = 6

   输出：[0,1]
   
   

### 1.2 解法一：暴力破解

最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。

当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。

```python
def twoSum_1(self, nums: list[int], target: int) -> list[int]:
    """
    :type nums: List[int]
    :type target: int
    :rtype: List[int]
    :description：两数之和，暴力破解
    """
    for index1 in range(len(nums)):
        for index2 in range(index1+1, len(nums)):
            if nums[index1] + nums[index2] == target:
                return [index1, index2]
```



### 1.3 解法二：哈希表

注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。

使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N) 降低到 O(1)O(1)。

这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。

```python
def twoSum_2(self, nums: list[int], target: int) -> list[int]:
    """
    :type nums: List[int]
    :type target: int
    :rtype: List[int]
    :description：两数之和，哈希表
    """
    hashtable = dict()
    for i, num in enumerate(nums):  # enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标
        if target - num in hashtable:  # key in dict：判断指定的键是否在字典中
            return [hashtable[target - num], i]
        hashtable[nums[i]] = i  # nums 中的数据进字典。nums[i] 为键，i为值
    return []
```

---



## 2 整数反转

### 2.1 算法要求

给你一个 32 位的有符号整数 x ，返回 x 中每位上的数字反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−2^31,  2^31 − 1] ，就返回 0。

假设环境不允许存储 64 位整数（有符号或无符号）。

1. 示例 1：

   输入：x = 123

   输出：321

2. 示例 2：

   输入：x = -123

   输出：-321

3. 示例 3：

   输入：x = 120

   输出：21

4. 示例 4：

   输入：x = 0

   输出：0



### 2.2 解法一：弹出和推入数字 & 溢出前进行检查

我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。

反转整数的方法可以与反转字符串进行类比。

我们想重复 “弹出”  xx 的最后一位数字，并将它 “推入” 到 rev 的后面。最后，rev 将与 xx 相反。

要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。

```python
# pop operation:
pop = x % 10;
x /= 10;

# push operation:
temp = rev * 10 + pop;
rev = temp;
```

但是，这种方法很危险，因为当 temp = rev⋅10+pop 时会导致溢出。幸运的是，事先检查这个语句是否会导致溢出很容易。在Python中可以设定 rev 的边界值，确定 rev 在边界之中即可

```python
def reverse(self, x: int) -> int:
    """
    :type x: int
    :rtype: int
    :description：整数反转
    """
    y, result = abs(x), 0 # 将 x 取绝对值，方便处理 负数，具体原因见 算法练习--2.3
    while y != 0:
        pop = y % 10
        y = y // 10 # 求余数，向下取整，单纯的 / 号，会使得 int 变成 float 类型
        result = result * 10 + pop
        #  边界的表示方法： boundry = (1<<31) -1 if x>0 else 1<<31。 result > boundry 即表示超过边界
        if -pow(2, 31) <= result <= pow(2, 31) - 1:
            continue
        else:
            return 0
    return result if x > 0 else -result
```



### 2.3 Python中负数取余的问题

C语言、java 这些是向0取值，-10 对 3 取余 得 -3 余 -1 ，

python 是向负无穷取值，-10 对 3 取余 得 -4 余 2.

在本题中，-123 % 10 = 7，因为 -123 对 10 取余 得 -13 余 7

---



## 3 回文数

### 3.1 算法要求

给你一个整数 x ，如果 x 是一个回文整数，返回 ture ；否则，返回 false 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。

1. 示例 1：

   输入：x = 121

   输出：true

2. 示例 2：

   输入：x = -121

   输出：false

   解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

3. 示例 3：

   输入：x = 10

   输出：false

   解释：从右向左读, 为 01 。因此它不是一个回文数。

4. 示例 4：

   输入：x = -101

   输出：false

提示：-2^31 <= x <= 2^31 - 1。



### 3.2 解法一：借助字符串

暴力破解，时间长，内存消耗大

```python
def is_palindrome(self, x) -> bool:
    """
    :type x: int
    :rtype: bool
    :description: 回文数判断，借助字符串
    """
    return str(x) == str(x)[::-1]
```

**注意：字符串截取**

```python
s = 'abcdefg'
a = s[0]  # 下标为 0 的字符
b = s[1]  # 下标为 1 的字符
c = s[0: ]  # 从下标为 0 的位置开始截取，直到最后一个字符
d = s[1:4]  # 从下标为 1 的位置开始截取，直到下标为 4 的字符，但不包含第四个字符
e = s * 2  # *号，重复字符串 s 两次，赋值给 e
f = s + 'abc'  # 字符串的加法运算，s 的末尾 加上 'abc'
g = s[1:4:2]  # 在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串

# 利用负数下标截取字符串
x = s[-4:-1] # 从下标为 -4 开始时截取 至 下标为 -1 前的字符：def
x = s[-1:-4] # 截取失败，截取字符串默认从前往后截取，s[4:1] 同样截取失败

# 注意特殊情况
x = s[4:1:-1] # 截取成功，x = edc。即逆置截取字符串，从索引为 4 开始，截取至 索引为 1，不包括索引1. 
x = s[::-1] # 逆置截取全部字符
x = s[::] # 截取全部字符串
```



### 3.3 解法二：反转一半的数字

**思路：**

第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。但是，如果反转后的数字大于 int.MAX，我们将遇到整数溢出问题。

按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。

例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们得知数字 1221 是回文。

**算法：**

首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。

除了 0 以外，所有个位是 0 的数字不可能是回文，因为最高位不等于 0。所以我们可以对所有大于 0 且个位是 0 的数字返回 false。

现在，让我们来考虑如何反转后半部分的数字：

对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。

现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？

由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。

![fig1](算法练习.assets/9_fig1.png)

```python
def is_palindrome_2(self, x) -> bool:
    """
    :type x: int
    :rtype: bool
    :description: 回文数判断，反转一半的数字
    """
    if x < 0 or (x % 10 == 0 and x != 0):
        return False
    reverted_number = 0
    while x > reverted_number:
        reverted_number = reverted_number * 10 + x % 10
        x //= 10
    return x == reverted_number or x == reverted_number // 10
```