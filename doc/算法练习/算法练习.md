# 简单算法分析

---

## 1 两数之和

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

你可以按任意顺序返回答案。

1. 示例 1：

   输入：nums = [2,7,11,15], target = 9

   输出：[0,1]

   解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

2. 示例 2：

   输入：nums = [3,2,4], target = 6

   输出：[1,2]

3. 示例 3：

   输入：nums = [3,3], target = 6

   输出：[0,1]
   
   

### 1.1 解法一：暴力破解

最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。

当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。

```python
def twoSum_1(self, nums: list[int], target: int) -> list[int]:
    """
    :type nums: List[int]
    :type target: int
    :rtype: List[int]
    :description：两数之和，暴力破解
    """
    for index1 in range(len(nums)):
        for index2 in range(index1+1, len(nums)):
            if nums[index1] + nums[index2] == target:
                return [index1, index2]
```



### 1.2 解法二：哈希表

注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。

使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N) 降低到 O(1)O(1)。

这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。

```python
def twoSum_2(self, nums: list[int], target: int) -> list[int]:
    """
    :type nums: List[int]
    :type target: int
    :rtype: List[int]
    :description：两数之和，哈希表
    """
    hashtable = dict()
    for i, num in enumerate(nums):  # enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标
        if target - num in hashtable:  # key in dict：判断指定的键是否在字典中
            return [hashtable[target - num], i]
        hashtable[nums[i]] = i  # nums 中的数据进字典。nums[i] 为键，i为值
    return []
```

---



## 2 整数反转

给你一个 32 位的有符号整数 x ，返回 x 中每位上的数字反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−2^31,  2^31 − 1] ，就返回 0。

假设环境不允许存储 64 位整数（有符号或无符号）。

1. 示例 1：

   输入：x = 123

   输出：321

2. 示例 2：

   输入：x = -123

   输出：-321

3. 示例 3：

   输入：x = 120

   输出：21

4. 示例 4：

   输入：x = 0

   输出：0



### 2.1 解法一：弹出和推入数字 & 溢出前进行检查

我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。

反转整数的方法可以与反转字符串进行类比。

我们想重复 “弹出”  xx 的最后一位数字，并将它 “推入” 到 rev 的后面。最后，rev 将与 xx 相反。

要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。

```python
# pop operation:
pop = x % 10;
x /= 10;

# push operation:
temp = rev * 10 + pop;
rev = temp;
```

但是，这种方法很危险，因为当 temp = rev⋅10+pop 时会导致溢出。幸运的是，事先检查这个语句是否会导致溢出很容易。在Python中可以设定 rev 的边界值，确定 rev 在边界之中即可

```python
def reverse(self, x: int) -> int:
    """
    :type x: int
    :rtype: int
    :description：整数反转
    """
    y, result = abs(x), 0 # 将 x 取绝对值，方便处理 负数，具体原因见 算法练习--2.3
    while y != 0:
        pop = y % 10
        y = y // 10 # 求余数，向下取整，单纯的 / 号，会使得 int 变成 float 类型
        result = result * 10 + pop
        #  边界的表示方法： boundry = (1<<31) -1 if x>0 else 1<<31。 result > boundry 即表示超过边界
        if -pow(2, 31) <= result <= pow(2, 31) - 1:
            continue
        else:
            return 0
    return result if x > 0 else -result
```



### 2.2 Python中负数取余的问题

C语言、java 这些是向0取值，-10 对 3 取余 得 -3 余 -1 ，

python 是向负无穷取值，-10 对 3 取余 得 -4 余 2.

在本题中，-123 % 10 = 7，因为 -123 对 10 取余 得 -13 余 7

---



## 3 回文数

给你一个整数 x ，如果 x 是一个回文整数，返回 ture ；否则，返回 false 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。

1. 示例 1：

   输入：x = 121

   输出：true

2. 示例 2：

   输入：x = -121

   输出：false

   解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

3. 示例 3：

   输入：x = 10

   输出：false

   解释：从右向左读, 为 01 。因此它不是一个回文数。

4. 示例 4：

   输入：x = -101

   输出：false

提示：-2^31 <= x <= 2^31 - 1。



### 3.1 解法一：借助字符串

暴力破解，时间长，内存消耗大

```python
def is_palindrome(self, x) -> bool:
    """
    :type x: int
    :rtype: bool
    :description: 回文数判断，借助字符串
    """
    return str(x) == str(x)[::-1]
```

**注意：字符串截取**

```python
s = 'abcdefg'
a = s[0]  # 下标为 0 的字符
b = s[1]  # 下标为 1 的字符
c = s[0: ]  # 从下标为 0 的位置开始截取，直到最后一个字符
d = s[1:4]  # 从下标为 1 的位置开始截取，直到下标为 4 的字符，但不包含第四个字符
e = s * 2  # *号，重复字符串 s 两次，赋值给 e
f = s + 'abc'  # 字符串的加法运算，s 的末尾 加上 'abc'
g = s[1:4:2]  # 在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串

# 利用负数下标截取字符串
x = s[-4:-1] # 从下标为 -4 开始时截取 至 下标为 -1 前的字符：def
x = s[-1:-4] # 截取失败，截取字符串默认从前往后截取，s[4:1] 同样截取失败

# 注意特殊情况
x = s[4:1:-1] # 截取成功，x = edc。即逆置截取字符串，从索引为 4 开始，截取至 索引为 1，不包括索引1. 
x = s[::-1] # 逆置截取全部字符
x = s[::] # 截取全部字符串
```



### 3.2 解法二：反转一半的数字

**思路：**

第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。但是，如果反转后的数字大于 int.MAX，我们将遇到整数溢出问题。

按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。

例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们得知数字 1221 是回文。

**算法：**

首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。

除了 0 以外，所有个位是 0 的数字不可能是回文，因为最高位不等于 0。所以我们可以对所有大于 0 且个位是 0 的数字返回 false。

现在，让我们来考虑如何反转后半部分的数字：

对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。

现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？

由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。

![fig1](算法练习.assets/9_fig1.png)

```python
def is_palindrome_2(self, x) -> bool:
    """
    :type x: int
    :rtype: bool
    :description: 回文数判断，反转一半的数字
    """
    if x < 0 or (x % 10 == 0 and x != 0):
        return False
    reverted_number = 0
    while x > reverted_number:
        reverted_number = reverted_number * 10 + x % 10
        x //= 10
    return x == reverted_number or x == reverted_number // 10
```

---



## 4 罗马数

罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

| 字符 | 数值 |
| :--: | :--: |
|  I   |  1   |
|  V   |  5   |
|  X   |  10  |
|  L   |  50  |
|  C   | 100  |
|  D   | 500  |
|  M   | 1000 |

例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

1. I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
2. X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
3. C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。

1. 示例 1:

   输入: "III"

   输出: 3

2. 示例 2:

   输入: "IV"

   输出: 4

3. 示例 3:

   输入: "IX"

   输出: 9

4. 示例 4:

   输入: "LVIII"

   输出: 58

   解释: L = 50, V= 5, III = 3.

5. 示例 5:

   输入: "MCMXCIV"

   输出: 1994

   解释: M = 1000, CM = 900, XC = 90, IV = 4.

**提示：**

1. 1 <= s.length <= 15
2. s 仅含字符 ('I', 'V', 'X', 'L', 'C', 'D', 'M')
3. 题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内
4. 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。
5. IC 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。
6. 关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。



### 4.1 解法一：暴力破解，字符串匹配

字符串依次匹配

```python
def romanToInt(self, s: str) -> int:
    """
    :type s: str
    :rtype: int
    :description: 罗马数
    """
    i, num = 0, 0
    while i < len(s):
        if s[i] == 'M':
            num = num + 1000
            i = i + 1
        elif s[i] == 'D':
            num = num + 500
            i = i + 1
        elif s[i] == 'C':
            if i == len(s) - 1:
                num = num + 100
                i = i + 1
            elif s[i + 1] == 'D':
                num = num + 400
                i = i + 2
            elif s[i + 1] == 'M':
                num = num + 900
                i = i + 2
            else:
                num = num + 100
                i = i + 1
        elif s[i] == 'L':
            num = num + 50
            i = i + 1
        elif s[i] == 'X':
            if i == len(s) - 1:
                num = num + 10
                i = i + 1
            elif s[i+1] == 'L':
                num = num + 40
                i = i + 2
            elif s[i+1] == 'C':
                num = num + 90
                i = i + 2
            else:
                num = num + 10
                i = i + 1
        elif s[i] == 'V':
            num = num + 5
            i = i + 1
        elif s[i] == 'I':
            if i == len(s)-1:
                num = num + 1
                i = i + 1
            elif s[i+1] == 'V':
                num = num + 4
                i = i + 2
            elif s[i+1] == 'X':
                num = num + 9
                i = i + 2
            else:
                num = num + 1
                i = i + 1
    return num
```



### 4.2 解法二：罗马数规律

按照题目的描述，可以总结如下规则：

1. 罗马数字由 I, V, X, L, C, D, M 构成；
2. 当小值在大值的左边，则减小值，如 IV=5-1=4；
3. 当小值在大值的右边，则加小值，如 VI=5+1=6；
4. 由上可知，右值永远为正，因此最后一位必然为正。

在代码实现上，可以往后看多一位，对比当前位与后一位的大小关系，从而确定当前位是加还是减法。当没有下一位时，做加法即可。

也可保留当前位的值，当遍历到下一位的时，对比保留值与遍历位的大小关系，再确定保留值为加还是减。最后一位做加法即可。

```python
# 自定义 get_value 函数
def romanToInt_2(self, s: str) -> int:
    """
    :type s: str
    :rtype: int
    :description: 罗马数，罗马数规律
    """
    prenum, num, sum = Solution.get_num(s[0]), 0, 0
    for i in range(1, len(s)):
        num = Solution.get_num(s[i])
        if prenum < num:
            sum = sum - prenum
        else:
            sum = sum + prenum
        prenum = num
    return sum + prenum

@classmethod  # 加入 @classmethod 注释，方便直接调用该方法
def get_num(cls, s: str) -> int:
    num = 0
    if s == 'M':
        num = 1000
    elif s == 'D':
        num = 500
    elif s == 'C':
        num = 100
    elif s == 'L':
        num = 50
    elif s == 'X':
        num = 10
    elif s == 'V':
        num = 5
    elif s == 'I':
        num = 1
    return num
 
# 利用哈希表取值
def romanToInt_3(self, s: str) -> int:
    """
    :type s: str
    :rtype: int
    :description: 罗马数，罗马数规律，利用哈希表取值
    """
    roman_int = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    int = 0
    for index in range(len(s)-1):
        if roman_int[s[index]] < roman_int[s[index+1]]:
            int -= roman_int[s[index]]
        else:
            int += roman_int[s[index]]
    return int + roman_int[s[-1]]
```



### 4.3 解法三：利用字典进行字符串匹配

构建一个字典记录所有罗马数字子串，注意长度为2的子串记录的值是（实际值 - 子串内左边罗马数字代表的数值）

这样一来，遍历整个 ss 的时候判断当前位置和前一个位置的两个字符组成的字符串是否在字典内，如果在就记录值，不在就说明当前位置不存在小数字在前面的情况，直接记录当前位置字符对应值

```python
def romanToInt_4(self, s: str) -> int:
    """
    :type s: str
    :rtype: int
    :description: 罗马数，利用字典进行字符串匹配
    """
    # 注意在字典中 IX = 8，因为对于 XIX，第一次str1 = XI，匹配到 I，则 result+1，第二次匹配到 IX，则result + 8，两次合起来实现 IX = 9
    d = {'I': 1, 'IV': 3, 'V': 5, 'IX': 8, 'X': 10, 'XL': 30, 'L': 50, 'XC': 80, 'C': 100, 'CD': 300, 'D': 500, 'CM': 800, 'M': 1000}
    result = 0
    for i, n in enumerate(s):
        str1 = s[max(i - 1, 0):i + 1]  # 作者解析中的2就是用这行代码实现的
        if str1 in d:
            result += d.get(str1)
        else:
            result += d[n]
    return result
```

---



## 5 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

1. 示例 1：

   输入：strs = ["flower","flow","flight"]

   输出："fl"

2. 示例 2：

   输入：strs = ["dog","racecar","car"]

   输出：""

   解释：输入不存在公共前缀。

提示：

- 0 <= strs.length <= 200
- 0 <= strs[i].length <= 200
- strs[i] 仅由小写英文字母组成



### 5.1 解法一：字符串截取，适用于Python

```python
def longestCommonPrefix_1(self, strs: List[str]) -> str:
    """
    :description: 最长公共前缀，字符串截取
    """
    if not strs:
        return ""
    else:
        str_1 = strs[0]
        for i in range(len(str_1)):
            for j in range(len(strs)):
                # 正常情况
                if strs[j][:i+1] != str_1[:i+1]:
                    return str_1[:i]
                else:
                    continue
        # 解决异常情况，当strs里的值都是相同的时候
        return str_1
 
def longestCommonPrefix_2(self, strs: List[str]) -> str:
    """
    :description: 最长公共前缀，字符串匹配，算法优化
    """
    if not strs:
        return ""
    # 利用 min 和 max 取 strs 中最长和最短的字符串
    str0 = min(strs)
    str1 = max(strs)
    for i in range(len(str0)):
        if str0[i] != str1[i]:
            return str0[:i]
    return str0
```



### 5.2 解法二：通用解法，纵向扫描

纵向扫描时，从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，当前列之前的部分为最长公共前缀。

![fig2](算法练习.assets/14_fig2.png)

```python
def longestCommonPrefix_2(self, strs: List[str]) -> str:
    """
    :description: 最长公共前缀，字符串匹配，算法优化
    """
    if not strs:
        return ""
    length, count = len(strs[0]), len(strs)
    for i in range(length):
        c = strs[0][i]
        if any(i == len(strs[j]) or strs[j][i] != c for j in range(1, count)):
            return strs[0][:i]

    return strs[0]
```

---



## 6 有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。

1. 示例 1：

   输入：s = "()"

   输出：true

2. 示例 2：

   输入：s = "()[]{}"

   输出：true

3. 示例 3：

   输入：s = "(]"

   输出：false

4. 示例 4：

   输入：s = "([)]"

   输出：false

5. 示例 5：

   输入：s = "{[]}"

   输出：true

提示：

- 1 <= s.length <= 10^4
- s 仅由括号 '()[]{}' 组成



### 6.1 解法一：标准解法，利用栈

**注意：**

Python中涉及字符串的匹配时可以利用字典简化代码

```python
def isValid_2(self, s: str) -> bool:
    """
    :description: 有效的括号，利用字典匹配
    :param s: 只含括号的字符串
    :return: bool
    """
    if len(s) % 2 == 1:
        return False
    else:
        pairs = {")": "(", "]": "[", "}": "{"}
        list_1 = []
        for ch in s:
            if ch in pairs:
                if not list_1 or list_1[-1] != pairs[ch]:
                    return False
                list_1.pop()
            else:
                list_1.append(ch)
        return not list_1
```

---



## 7 删除排序数组中的重复项

给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

1. 示例 1:

   给定数组 nums = [1, 1, 2], 

   函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

   你不需要考虑数组中超出新长度后面的元素。

2. 示例 2:

   给定 nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4],

   函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

   你不需要考虑数组中超出新长度后面的元素。



### 7.1 解法：双指针

**算法：**

数组完成排序后，我们可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i] = nums[j]，我们就增加 j 以跳过重复项。

当我们遇到 nums[j] != nums[i] 时，跳过重复项的运行已经结束，因此我们必须把 nums[j] 的值复制到nums[i+1]。然后递增 i，接着我们将再次重复相同的过程，直到 j 到达数组的末尾为止。

```python
def removeDuplicates(self, nums: List[int]) -> int:
    """
    :description: 删除有序数组中的重复项，双指针
    """
    if not nums:
        return 0
    i = 0
    for j in range(1, len(nums)):
        if nums[j] != nums[i]:
            i = i + 1
            nums[i] = nums[j]
    return i+1
```

---



## 8 移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

1. 示例 1：

   输入：nums = [3,2,2,3], val = 3

   输出：2, nums = [2,2]
   解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。

2. 示例 2：

   输入：nums = [0,1,2,2,3,0,4,2], val = 2
   输出：5, nums = [0,1,4,0,3]
   解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。



### 8.1 解法一：双指针，val后移

当我们遇到 nums[i]=val 时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 1。

请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素。

```python
def removeElement_1(self, nums: List[int], val: int) -> int:
    """
    :description: 移除数组中的指定元素，双指针，val后移
    :param nums:
    :param val:
    :return:
    """
    i, count = 0, len(nums)
    while i < count:
        if nums[i] == val:
            nums[i] = nums[count-1]
            count -= 1
        else:
            i += 1

    return count
```



### 8.2 解法二：双指针，元素前移

双指针其实就是两个数，分别代表两个index，表示数组中第几个数的意思。比如这里，我们让a代表一个index，b代表一个index

然后我们让a一直往后移动，相当于nums[a]从数组第一个数遍历到最后一个数。当且仅当我们发现nums[a] != val 的时候，我们把这个数拷贝到 b 指向的位置，默认b是从0开始的，然后 b += 1指向下一个位置。

这样我们就保证了前b个数，就是我们要的结果。不重复的数。

```python
def removeElement_2(self, nums: List[int], val: int) -> int:
    """
    :description: 移除数组中的指定元素，双指针，元素前移
    :param nums:
    :param val:
    :return:
    """
    a, b = 0, 0

    while a < len(nums):
        if nums[a] != val:
            nums[b] = nums[a]
            b += 1
        a += 1

    return b
```

---



## 9 实现strStr() 

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

1. 示例 1：

   输入: haystack = "hello", needle = "ll"

   输出: 2

2. 示例 2:

   输入: haystack = "aaaaa", needle = "bba"

   输出: -1

说明:

1. 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。



### 9.1 解法一：字符串匹配

最直接的方法 - 沿着字符串逐步移动滑动窗口，将窗口内的子串与 needle 字符串比较。

```python
def strStr(self, haystack: str, needle: str) -> int:
    """
    :description: 实现strStr() 函数
    :param haystack:
    :param needle:
    :return:
    """
    if needle == "":
        return 0
    elif needle != "" and haystack == "":
        return -1
    else:
        len_1, len_2 = len(haystack), len(needle)
        for i in range(len_1):
            if haystack[i] == needle[0]:
                if i + len_2 <= len_1:
                    if haystack[i:i+len_2] == needle:
                        return i
        return -1
```

---



## 10 搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

1. 示例 1:

   输入: [1,3,5,6], 5

   输出: 2

2. 示例 2:

   输入: [1,3,5,6], 2

   输出: 1

3. 示例 3:

   输入: [1,3,5,6], 7

   输出: 4

4. 示例 4:

   输入: [1,3,5,6], 0

   输出: 0



### 10.1 解法一：暴力破解

依次查找，获取 nums 中第一个 大于等于 target 的下标

```python
def searchInsert(self, nums: List[int], target: int) -> int:
    """
    :description: 搜索插入位置
    :param nums:
    :param target:
    :return:
    """
    if not nums:
        return 0
    for i in range(0, len(nums)):
        if nums[i] >= target:
            return i
    return len(nums)
```



### 10.2 解法二：二分查找

假设题意是叫你在排序数组中寻找是否存在一个目标值，那么训练有素的读者肯定立马就能想到利用二分法在 O(logn) 的时间内找到是否存在目标值。但这题还多了个额外的条件，即如果不存在数组中的时候需要返回按顺序插入的位置，那我们还能用二分法么？答案是可以的，我们只需要稍作修改即可。

考虑这个插入的位置 pos，它成立的条件为：nums[pos−1] < target ≤ nums[pos]

其中 nums 代表排序数组。由于如果存在这个目标值，我们返回的索引也是 pos，因此我们可以将两个条件合并得出最后的目标：「在一个有序数组中找第一个大于等于 target 的下标」。

问题转化到这里，直接套用二分法即可，即不断用二分法逼近查找第一个大于等于 target 的下标 。下文给出的代码是笔者习惯的二分写法，ans 初值设置为数组长度可以省略边界条件的判断，因为存在一种情况是 target 大于数组中的所有数，此时需要插入到数组长度的位置。

```python
def searchInsert(self, nums: List[int], target: int) -> int:
    """
    :description: 搜索插入位置，二分查找
    :param nums:
    :param target:
    :return:
    """
    left, right = 0, len(nums)
    while left < right:
        mid = (left + right) // 2
        if nums[mid] < target:
            left = mid + 1
        else:
            right = mid
    return left
```

---



## 11 外观数列

给定一个正整数 n ，输出外观数列的第 n 项。

「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。

你可以将其视作是由递归公式定义的数字字符串序列：

- countAndSay(1) = "1"
- countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。

前五项如下：

1.     1
2.     11
3.     21
4.     1211
5.     111221
第一项是数字 1 
描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 "11"
描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 "21"
描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 "1211"
描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"

要描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。

例如，数字字符串 "3322251" 的描述如下图：

![img](算法练习.assets/countandsay.jpg)

1. 示例 1：

   输入：n = 1

   输出："1"，这是一个基本样例。

2. 示例 2：

   输入：n = 4

   输出："1211"

   解释：

   - countAndSay(1) = "1"
   - countAndSay(2) = 读 "1" = 一 个 1 = "11"
   - countAndSay(3) = 读 "11" = 二 个 1 = "21"
   - countAndSay(4) = 读 "21" = 一 个 2 + 一 个 1 = "12" + "11" = "1211"



### 11.1 解法：递归

利用递归，根据 前项 获取 后项

```python
def countAndSay(self, n: int) -> str:
    """
    :description: 输出外观数列的第 n 项
    :param n:
    :return:
    """
    if n == 1:
        return "1"
    else:
        str_num = "1"
        for i in range(n-1):
            str_num = Solution.description(str_num)
        return str_num

@classmethod
def description(cls, str_num: str) -> str:
    """
    方法用于：被 countAndSay 调用，描述num
    """
    val = str_num[0]
    return_str = ""
    j = 0
    for i in range(len(str_num)):
        if str_num[i] == val:
            j += 1
        else:
            return_str = return_str + str(j) + val
            val = str_num[i]
            j = 1

    # 解决 “11” 这种情况，避免循环结束后有数字的未被描述
    return_str = return_str + str(j) + val
    return return_str
```

---



## 12 最大子序和

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

1. 示例 1：

   输入：nums = [-2,1,-3,4,-1,2,1,-5,4]

   输出：6

   解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

2. 示例 2：

   输入：nums = [1]

   输出：1

3. 示例 3：

   输入：nums = [0]

   输出：0

4. 示例 4：

   输入：nums = [-1]

   输出：-1

5. 示例 5：

   输入：nums = [-100000]

   输出：-100000



### 12.1 解法一：动态规划

假设 nums 数组的长度是 n，下标从 0 到 n−1。

我们用 f(i) 代表以第 i 个数结尾的「连续子数组的最大和」，那么很显然我们要求的答案就是：
$$
max{f(i)}
$$
因此我们只需要求出每个位置的 f(i)，然后返回 f 数组中的最大值即可。那么我们如何求 f(i) 呢？我们可以考虑 nums[i] 单独成为一段还是加入 f(i−1) 对应的那一段，这取决于 nums[i] 和 f(i-1) + nums[i] 的大小，我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：
$$
f(i)=max[f(i−1)+nums[i],nums[i]]
$$
不难给出一个时间复杂度 O(n)、空间复杂度 O(n) 的实现，即用一个 f 数组来保存 f(i) 的值，用一个循环求出所有 f(i)。考虑到 f(i) 只和 f(i−1) 相关，于是我们可以只用一个变量 pre 来维护对于当前 f(i) 的 f(i−1) 的值是多少，从而让空间复杂度降低到 O(1)，这有点类似「滚动数组」的思想。

```python
def maxSubArray_1(self, nums: List[int]) -> int:
    """
    :description: 最大子序和，动态规划
    :param nums: list[int]
    :return: int
    """
    pre, max_ans = 0, nums[0]
    for i in nums:
        pre = max(pre+i, i)
        max_ans = max(max_ans, pre)

    return max_ans
```



### 12.2 解法二：分治

我们定义一个操作 **get(a, l, r)** 表示查询 **a** 序列 **[l，r]** 区间内的最大子段和，那么最终我们要求的答案就是 **get(nums, 0, nums.size() - 1)**。如何分治实现这个操作呢？

对于一个区间 **[l，r]**，我们取 
$$
m = ⌊ (l+r) / 2 ⌋
$$
对区间 **[l，m]** 和 **[m+1，r]** 分治求解。当递归逐层深入直到区间长度缩小为 **1** 的时候，递归「开始回升」。这个时候我们考虑如何通过 **[l，m]** 区间的信息和 **[m+1，r]** 区间的信息合并成区间 **[l，r]** 的信息。最关键的两个问题是：

- 我们要维护区间的哪些信息呢？
- 我们如何合并这些信息呢？

对于一个区间 **[l，r]**，我们可以维护四个量：

- **lSum** 表示 **[l，r]** 内以 **l** 为左端点的最大子段和
- **rSum** 表示 **[l，r]** 内以 **r** 为右端点的最大子段和 
- **mSum** 表示 **[l，r]** 内的最大子段和 
- **iSum** 表示 **[l，r]** 的区间和

以下简称 **[l，m]** 为 **[l，r]** 的「左子区间」，**[m+1，r]** 为 **[l，r]** 的「右子区间」。我们考虑如何维护这些量呢（如何通过左右子区间的信息合并得到 **[l，r]** 的信息）？对于长度为 **1** 的区间 **[i，i]**，四个量的值都和 **nums[ i ]** 相等。对于长度大于 **1** 的区间：

1. 首先最好维护的是 **iSum**，区间 **[l，r]** 的 **iSum** 就等于「左子区间」的 **iSum** 加上「右子区间」的 **iSum**。 
2. 对于 **[l，r]** 的 **lSum**，存在两种可能，它要么等于「左子区间」的 **lSum**，要么等于「左子区间」的 **iSum** 加上「右子区间」的 **lSum**，二者取大。 
3. 对于 **[l，r]** 的 **rSum**，同理，它要么等于「右子区间」的 **rSum**，要么等于「右子区间」的 **iSum** 加上「左子区间」的 **rSum**，二者取大。 
4. 当计算好上面的三个量之后，就很好计算 **[l，r]** 的 **mSum** 了。我们可以考虑 **[l，r]** 的 **mSum** 对应的区间是否跨越 **m** —— 它可能不跨越 **m**，也就是说 **[l，r]** 的 **mSum** 可能是「左子区间」的 **mSum** 和 「右子区间」的 **mSum** 中的一个；它也可能跨越 m，可能是「左子区间」的 **rSum** 和 「右子区间」的 **lSum** 求和。三者取大。

```python
def maxSubArray_2(self, nums: List[int]) -> int:
    """
    :description: 最大子序和，分治
    :param nums: list[int]
    :return: int
    """
    n = len(nums)
    # 递归终止条件
    if n == 1:
        return nums[0]
    else:
        # 递归计算左半边最大子序和
        max_left = self.maxSubArray(nums[0:len(nums) // 2])
        # 递归计算右半边最大子序和
        max_right = self.maxSubArray(nums[len(nums) // 2:len(nums)])

    # 计算中间的最大子序和，从右到左计算左边的最大子序和，从左到右计算右边的最大子序和，再相加
    max_l = nums[len(nums) // 2 - 1]
    tmp = 0
    for i in range(len(nums) // 2 - 1, -1, -1):
        tmp += nums[i]
        max_l = max(tmp, max_l)
    max_r = nums[len(nums) // 2]
    tmp = 0
    for i in range(len(nums) // 2, len(nums)):
        tmp += nums[i]
        max_r = max(tmp, max_r)
    # 返回三个中的最大值
    return max(max_right, max_left, max_l + max_r)
```

---



## 13 最后一个单词

给你一个字符串 s，由若干单词组成，单词之间用空格隔开。返回字符串中最后一个单词的长度。如果不存在最后一个单词，请返回 0 。

单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。

1. 示例 1：

   输入：s = "Hello World"

   输出：5

2. 示例 2：

   输入：s = " "

   输出：0

提示：

- 1 <= s.length <= 10^4
- s 仅有英文字母和空格 ' ' 组成



### 13.1 解法一

1. 从后往前过滤
2. 利用 length 记录长度，j 记录索引位置
3. 注意末尾的空格处理

```python
def lengthOfLastWord(self, s: str) -> int:
    """
    :description: 最后一个单词的长度
    :param s: str
    :return: int
    """
    length, j = 0, -1
    for i in range(len(s)):
        if s[j] == " ":
            if length == 0:
                j -= 1
            else:
                return length
        else:
            length += 1
            j -= 1
    return length
```

---



## 14 加一

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

1. 示例 1：

   输入：digits = [1,2,3]

   输出：[1,2,4]

   解释：输入数组表示数字 123。

2. 示例 2：

   输入：digits = [4,3,2,1]

   输出：[4,3,2,2]

   解释：输入数组表示数字 4321。

3. 示例 3：

   输入：digits = [0]

   输出：[1]

4. 示例4：

   输入：digits = [9]

   输出：[1, 0]



### 14.1 解法一

从后往前遍历

1. 当数字加一之后变为  9，则该位变为 0，其前一位 +1
2. 当第一位数字为 9，则该位变为 0，数组在索引为 0 的地方插入一位 1

# 中等算法分析

---

## 1 去除重复字母

给你一个字符串 `s` ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 **返回结果的字典序最小**（要求不能打乱其他字符的相对位置）。

示例 1：

- 输入：s = "bcabc"
- 输出："abc"

示例 2：

- 输入：s = "cbacdcbc"
- 输出："acdb"

提示：

1. 1 <= s.length <= 10^4
2. s 由小写英文字母组成

解释：字符串字典序

- 字典序遵循的是逐字符比较的方式，越靠左的字符越会被先比较;

- 逐字符比较过程中，一旦发现某一对被比较的字符之间不相等时，这一对字符的大小关系即为这一对字符串的大小关系："abc" < "abd"

- 逐字符比较过程中，一旦出现某一个字符串的所有字符都已经经过比较，而另一字符串还存在未被比较的字符时，较短的字符串更小。"abc" < "abcde"

- 如果所有字符串内的字符都被发现相等，则这两个字符串相等



### 1.1 解法一：贪心+单调栈

【字符串删除一个字符使其字典序最小的贪心策略】：

对于两个长度相同的字符串，最左边不同的字符决定了其字典序大小，例如，对于 A = xxaxxx，B = xxbxxx，如果 a > b， 则 A > B。

哪个字符串大取决于两个字符串中第1个对应不相等的字符，所以我们应该将最小的字符尽可能的放在前面。

对于一个字符串s[0...n-1]，如果必须删除1个字符使其删除后的字符串字典序最小

【删除策略】就是：

1. 从左往右找到第1个降序的位置i（s[i] > s[i+1]），删除s[i]；

   例："abcb"，应该删除 'c' 字符，这样删除一个字符后，字典序最小

2. 如果不存在降序位置，即字符串是升序的（[i+1]  >= [i]），删除末尾字符（字典序最大）；例："abcd"，应该删除 'd' 字符，这样删除一个字符后，字典序最小。

3. 如果删除k个字符使其删除后字典序最小，等同与先删除1个字符使其字典序最小，删除后的新字符串便形成了一个【子问题】，继续同样策略。

【算法思路】：

1. 维护一个词频表，表示每个字符后续可供选择的数量

2. 从左往右遍历每个字符，每次遍历，当前字符消耗1个（后续可供选择的数量减1）
   1. 如果当前字符后续已经没有可供选择数量了（<1），当前字符没得选了，只能选择要；
   2. 如果当前字符后续仍有数量（>=1），可以选择要当前字符，也可以选择不要，怎么选？

【一个字符要还是不要的选择策略】：

借助于上面描述的【字符串删除一个字符使其字典序最小的贪心策略】：

1. 如果当前保留的字符串的前一个字符字典序 > 当前字符，删除前一个字符，选择要当前字符；

2. 否则，选择删除当前字符，要前一个字符

【通过单调栈维护当前已经选择的字符】：

如果选择要一个字符，是否可以入栈，还需要判断之前是否已经选择过该字符：该字符是否存在单调栈中。

由于只有26个小写字母，可用一个bool数组即可代替Set结构。

```python
def removeDuplicateLetters(self, s: str) -> str:
    """
    :description: 移除重复字母
    :param s: str
    :return: str
    """
    # 计算每个字母在s中出现的次数，记录在cha_dict中：
    cha_dict = {}
    for cha in s:
        if cha not in cha_dict :
            cha_dict[cha] = 0
        cha_dict[cha] += 1

    # 建立一个栈tmp,保持栈是字典序最小：
    tmp = ['0']  # 为了防止出现tmp[-1]报错，左边加入最小哨兵
    for cha in s:  # 遍历字符串
        if cha not in tmp:  # 如果当前字符如果不在栈中，需要把它安排在合适的位置。
            while cha < tmp[-1]:
                if cha_dict[tmp[-1]] > 0:  # 当栈顶元素比当前字符大，且之后还会出现，则将其删除
                    del tmp[-1]
                else:  # 当栈顶元素不会再出现时，停止
                    break
            tmp.append(cha)
        # 如果当前字符如果已经在栈中，则它已经是在目前的最优位置了，不需要进行处理。
        cha_dict[cha] -= 1  # 当前元素的剩余数量-1
    ans = ''.join(tmp[1:])
    return ans
```

---

# 算法思路

---

## 1 分治

## 2 动态规划

## 3 贪心算法