[TOC]



# 简单算法分析

---

## 1 两数之和

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

你可以按任意顺序返回答案。

1. 示例 1：

   输入：nums = [2,7,11,15], target = 9

   输出：[0,1]

   解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

2. 示例 2：

   输入：nums = [3,2,4], target = 6

   输出：[1,2]

3. 示例 3：

   输入：nums = [3,3], target = 6

   输出：[0,1]
   
   

### 1.1 解法一：暴力破解

最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。

当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。

```python
def twoSum_1(self, nums: list[int], target: int) -> list[int]:
    """
    :type nums: List[int]
    :type target: int
    :rtype: List[int]
    :description：两数之和，暴力破解
    """
    for index1 in range(len(nums)):
        for index2 in range(index1+1, len(nums)):
            if nums[index1] + nums[index2] == target:
                return [index1, index2]
```



### 1.2 解法二：哈希表

注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。

使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N) 降低到 O(1)O(1)。

这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。

```python
def twoSum_2(self, nums: list[int], target: int) -> list[int]:
    """
    :type nums: List[int]
    :type target: int
    :rtype: List[int]
    :description：两数之和，哈希表
    """
    hashtable = dict()
    for i, num in enumerate(nums):  # enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标
        if target - num in hashtable:  # key in dict：判断指定的键是否在字典中
            return [hashtable[target - num], i]
        hashtable[nums[i]] = i  # nums 中的数据进字典。nums[i] 为键，i为值
    return []
```

---



## 2 整数反转

给你一个 32 位的有符号整数 x ，返回 x 中每位上的数字反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−2^31,  2^31 − 1] ，就返回 0。

假设环境不允许存储 64 位整数（有符号或无符号）。

1. 示例 1：

   输入：x = 123

   输出：321

2. 示例 2：

   输入：x = -123

   输出：-321

3. 示例 3：

   输入：x = 120

   输出：21

4. 示例 4：

   输入：x = 0

   输出：0



### 2.1 解法一：弹出和推入数字 & 溢出前进行检查

我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。

反转整数的方法可以与反转字符串进行类比。

我们想重复 “弹出”  xx 的最后一位数字，并将它 “推入” 到 rev 的后面。最后，rev 将与 xx 相反。

要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。

```python
# pop operation:
pop = x % 10;
x /= 10;

# push operation:
temp = rev * 10 + pop;
rev = temp;
```

但是，这种方法很危险，因为当 temp = rev⋅10+pop 时会导致溢出。幸运的是，事先检查这个语句是否会导致溢出很容易。在Python中可以设定 rev 的边界值，确定 rev 在边界之中即可

```python
def reverse(self, x: int) -> int:
    """
    :type x: int
    :rtype: int
    :description：整数反转
    """
    y, result = abs(x), 0 # 将 x 取绝对值，方便处理 负数，具体原因见 算法练习--2.3
    while y != 0:
        pop = y % 10
        y = y // 10 # 求余数，向下取整，单纯的 / 号，会使得 int 变成 float 类型
        result = result * 10 + pop
        #  边界的表示方法： boundry = (1<<31) -1 if x>0 else 1<<31。 result > boundry 即表示超过边界
        if -pow(2, 31) <= result <= pow(2, 31) - 1:
            continue
        else:
            return 0
    return result if x > 0 else -result
```



### 2.2 Python中负数取余的问题

C语言、java 这些是向0取值，-10 对 3 取余 得 -3 余 -1 ，

python 是向负无穷取值，-10 对 3 取余 得 -4 余 2.

在本题中，-123 % 10 = 7，因为 -123 对 10 取余 得 -13 余 7

---



## 3 回文数

给你一个整数 x ，如果 x 是一个回文整数，返回 ture ；否则，返回 false 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。

1. 示例 1：

   输入：x = 121

   输出：true

2. 示例 2：

   输入：x = -121

   输出：false

   解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

3. 示例 3：

   输入：x = 10

   输出：false

   解释：从右向左读, 为 01 。因此它不是一个回文数。

4. 示例 4：

   输入：x = -101

   输出：false

提示：-2^31 <= x <= 2^31 - 1。



### 3.1 解法一：借助字符串

暴力破解，时间长，内存消耗大

```python
def is_palindrome(self, x) -> bool:
    """
    :type x: int
    :rtype: bool
    :description: 回文数判断，借助字符串
    """
    return str(x) == str(x)[::-1]
```

**注意：字符串截取**

```python
s = 'abcdefg'
a = s[0]  # 下标为 0 的字符
b = s[1]  # 下标为 1 的字符
c = s[0: ]  # 从下标为 0 的位置开始截取，直到最后一个字符
d = s[1:4]  # 从下标为 1 的位置开始截取，直到下标为 4 的字符，但不包含第四个字符
e = s * 2  # *号，重复字符串 s 两次，赋值给 e
f = s + 'abc'  # 字符串的加法运算，s 的末尾 加上 'abc'
g = s[1:4:2]  # 在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串

# 利用负数下标截取字符串
x = s[-4:-1] # 从下标为 -4 开始时截取 至 下标为 -1 前的字符：def
x = s[-1:-4] # 截取失败，截取字符串默认从前往后截取，s[4:1] 同样截取失败

# 注意特殊情况
x = s[4:1:-1] # 截取成功，x = edc。即逆置截取字符串，从索引为 4 开始，截取至 索引为 1，不包括索引1. 
x = s[::-1] # 逆置截取全部字符
x = s[::] # 截取全部字符串
```



### 3.2 解法二：反转一半的数字

**思路：**

第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。但是，如果反转后的数字大于 int.MAX，我们将遇到整数溢出问题。

按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。

例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们得知数字 1221 是回文。

**算法：**

首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。

除了 0 以外，所有个位是 0 的数字不可能是回文，因为最高位不等于 0。所以我们可以对所有大于 0 且个位是 0 的数字返回 false。

现在，让我们来考虑如何反转后半部分的数字：

对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。

现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？

由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。

![fig1](算法练习.assets/9_fig1.png)

```python
def is_palindrome_2(self, x) -> bool:
    """
    :type x: int
    :rtype: bool
    :description: 回文数判断，反转一半的数字
    """
    if x < 0 or (x % 10 == 0 and x != 0):
        return False
    reverted_number = 0
    while x > reverted_number:
        reverted_number = reverted_number * 10 + x % 10
        x //= 10
    return x == reverted_number or x == reverted_number // 10
```

---



## 4 罗马数

罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

| 字符 | 数值 |
| :--: | :--: |
|  I   |  1   |
|  V   |  5   |
|  X   |  10  |
|  L   |  50  |
|  C   | 100  |
|  D   | 500  |
|  M   | 1000 |

例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

1. I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
2. X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
3. C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。

1. 示例 1:

   输入: "III"

   输出: 3

2. 示例 2:

   输入: "IV"

   输出: 4

3. 示例 3:

   输入: "IX"

   输出: 9

4. 示例 4:

   输入: "LVIII"

   输出: 58

   解释: L = 50, V= 5, III = 3.

5. 示例 5:

   输入: "MCMXCIV"

   输出: 1994

   解释: M = 1000, CM = 900, XC = 90, IV = 4.

**提示：**

1. 1 <= s.length <= 15
2. s 仅含字符 ('I', 'V', 'X', 'L', 'C', 'D', 'M')
3. 题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内
4. 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。
5. IC 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。
6. 关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。



### 4.1 解法一：暴力破解，字符串匹配

字符串依次匹配

```python
def romanToInt(self, s: str) -> int:
    """
    :type s: str
    :rtype: int
    :description: 罗马数
    """
    i, num = 0, 0
    while i < len(s):
        if s[i] == 'M':
            num = num + 1000
            i = i + 1
        elif s[i] == 'D':
            num = num + 500
            i = i + 1
        elif s[i] == 'C':
            if i == len(s) - 1:
                num = num + 100
                i = i + 1
            elif s[i + 1] == 'D':
                num = num + 400
                i = i + 2
            elif s[i + 1] == 'M':
                num = num + 900
                i = i + 2
            else:
                num = num + 100
                i = i + 1
        elif s[i] == 'L':
            num = num + 50
            i = i + 1
        elif s[i] == 'X':
            if i == len(s) - 1:
                num = num + 10
                i = i + 1
            elif s[i+1] == 'L':
                num = num + 40
                i = i + 2
            elif s[i+1] == 'C':
                num = num + 90
                i = i + 2
            else:
                num = num + 10
                i = i + 1
        elif s[i] == 'V':
            num = num + 5
            i = i + 1
        elif s[i] == 'I':
            if i == len(s)-1:
                num = num + 1
                i = i + 1
            elif s[i+1] == 'V':
                num = num + 4
                i = i + 2
            elif s[i+1] == 'X':
                num = num + 9
                i = i + 2
            else:
                num = num + 1
                i = i + 1
    return num
```



### 4.2 解法二：罗马数规律

按照题目的描述，可以总结如下规则：

1. 罗马数字由 I, V, X, L, C, D, M 构成；
2. 当小值在大值的左边，则减小值，如 IV=5-1=4；
3. 当小值在大值的右边，则加小值，如 VI=5+1=6；
4. 由上可知，右值永远为正，因此最后一位必然为正。

在代码实现上，可以往后看多一位，对比当前位与后一位的大小关系，从而确定当前位是加还是减法。当没有下一位时，做加法即可。

也可保留当前位的值，当遍历到下一位的时，对比保留值与遍历位的大小关系，再确定保留值为加还是减。最后一位做加法即可。

```python
# 自定义 get_value 函数
def romanToInt_2(self, s: str) -> int:
    """
    :type s: str
    :rtype: int
    :description: 罗马数，罗马数规律
    """
    prenum, num, sum = Solution.get_num(s[0]), 0, 0
    for i in range(1, len(s)):
        num = Solution.get_num(s[i])
        if prenum < num:
            sum = sum - prenum
        else:
            sum = sum + prenum
        prenum = num
    return sum + prenum

@classmethod  # 加入 @classmethod 注释，方便直接调用该方法
def get_num(cls, s: str) -> int:
    num = 0
    if s == 'M':
        num = 1000
    elif s == 'D':
        num = 500
    elif s == 'C':
        num = 100
    elif s == 'L':
        num = 50
    elif s == 'X':
        num = 10
    elif s == 'V':
        num = 5
    elif s == 'I':
        num = 1
    return num
 
# 利用哈希表取值
def romanToInt_3(self, s: str) -> int:
    """
    :type s: str
    :rtype: int
    :description: 罗马数，罗马数规律，利用哈希表取值
    """
    roman_int = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    int = 0
    for index in range(len(s)-1):
        if roman_int[s[index]] < roman_int[s[index+1]]:
            int -= roman_int[s[index]]
        else:
            int += roman_int[s[index]]
    return int + roman_int[s[-1]]
```



### 4.3 解法三：利用字典进行字符串匹配

构建一个字典记录所有罗马数字子串，注意长度为2的子串记录的值是（实际值 - 子串内左边罗马数字代表的数值）

这样一来，遍历整个 ss 的时候判断当前位置和前一个位置的两个字符组成的字符串是否在字典内，如果在就记录值，不在就说明当前位置不存在小数字在前面的情况，直接记录当前位置字符对应值

```python
def romanToInt_4(self, s: str) -> int:
    """
    :type s: str
    :rtype: int
    :description: 罗马数，利用字典进行字符串匹配
    """
    # 注意在字典中 IX = 8，因为对于 XIX，第一次str1 = XI，匹配到 I，则 result+1，第二次匹配到 IX，则result + 8，两次合起来实现 IX = 9
    d = {'I': 1, 'IV': 3, 'V': 5, 'IX': 8, 'X': 10, 'XL': 30, 'L': 50, 'XC': 80, 'C': 100, 'CD': 300, 'D': 500, 'CM': 800, 'M': 1000}
    result = 0
    for i, n in enumerate(s):
        str1 = s[max(i - 1, 0):i + 1]  # 作者解析中的2就是用这行代码实现的
        if str1 in d:
            result += d.get(str1)
        else:
            result += d[n]
    return result
```

---



## 5 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

1. 示例 1：

   输入：strs = ["flower","flow","flight"]

   输出："fl"

2. 示例 2：

   输入：strs = ["dog","racecar","car"]

   输出：""

   解释：输入不存在公共前缀。

提示：

- 0 <= strs.length <= 200
- 0 <= strs[i].length <= 200
- strs[i] 仅由小写英文字母组成



### 5.1 解法一：字符串截取，适用于Python

```python
def longestCommonPrefix_1(self, strs: List[str]) -> str:
    """
    :description: 最长公共前缀，字符串截取
    """
    if not strs:
        return ""
    else:
        str_1 = strs[0]
        for i in range(len(str_1)):
            for j in range(len(strs)):
                # 正常情况
                if strs[j][:i+1] != str_1[:i+1]:
                    return str_1[:i]
                else:
                    continue
        # 解决异常情况，当strs里的值都是相同的时候
        return str_1
 
def longestCommonPrefix_2(self, strs: List[str]) -> str:
    """
    :description: 最长公共前缀，字符串匹配，算法优化
    """
    if not strs:
        return ""
    # 利用 min 和 max 取 strs 中最长和最短的字符串
    str0 = min(strs)
    str1 = max(strs)
    for i in range(len(str0)):
        if str0[i] != str1[i]:
            return str0[:i]
    return str0
```



### 5.2 解法二：通用解法，纵向扫描

纵向扫描时，从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，当前列之前的部分为最长公共前缀。

![fig2](算法练习.assets/14_fig2.png)

```python
def longestCommonPrefix_2(self, strs: List[str]) -> str:
    """
    :description: 最长公共前缀，字符串匹配，算法优化
    """
    if not strs:
        return ""
    length, count = len(strs[0]), len(strs)
    for i in range(length):
        c = strs[0][i]
        if any(i == len(strs[j]) or strs[j][i] != c for j in range(1, count)):
            return strs[0][:i]

    return strs[0]
```

---



## 6 有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。

1. 示例 1：

   输入：s = "()"

   输出：true

2. 示例 2：

   输入：s = "()[]{}"

   输出：true

3. 示例 3：

   输入：s = "(]"

   输出：false

4. 示例 4：

   输入：s = "([)]"

   输出：false

5. 示例 5：

   输入：s = "{[]}"

   输出：true

提示：

- 1 <= s.length <= 10^4
- s 仅由括号 '()[]{}' 组成



### 6.1 解法一：标准解法，利用栈

**注意：**

Python中涉及字符串的匹配时可以利用字典简化代码

```python
def isValid_2(self, s: str) -> bool:
    """
    :description: 有效的括号，利用字典匹配
    :param s: 只含括号的字符串
    :return: bool
    """
    if len(s) % 2 == 1:
        return False
    else:
        pairs = {")": "(", "]": "[", "}": "{"}
        list_1 = []
        for ch in s:
            if ch in pairs:
                if not list_1 or list_1[-1] != pairs[ch]:
                    return False
                list_1.pop()
            else:
                list_1.append(ch)
        return not list_1
```

---



## 7 删除排序数组中的重复项

给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

1. 示例 1:

   给定数组 nums = [1, 1, 2], 

   函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

   你不需要考虑数组中超出新长度后面的元素。

2. 示例 2:

   给定 nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4],

   函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

   你不需要考虑数组中超出新长度后面的元素。



### 7.1 解法：双指针

**算法：**

数组完成排序后，我们可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i] = nums[j]，我们就增加 j 以跳过重复项。

当我们遇到 nums[j] != nums[i] 时，跳过重复项的运行已经结束，因此我们必须把 nums[j] 的值复制到nums[i+1]。然后递增 i，接着我们将再次重复相同的过程，直到 j 到达数组的末尾为止。

```python
def removeDuplicates(self, nums: List[int]) -> int:
    """
    :description: 删除有序数组中的重复项，双指针
    """
    if not nums:
        return 0
    i = 0
    for j in range(1, len(nums)):
        if nums[j] != nums[i]:
            i = i + 1
            nums[i] = nums[j]
    return i+1
```

---



## 8 移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

1. 示例 1：

   输入：nums = [3,2,2,3], val = 3

   输出：2, nums = [2,2]
   解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。

2. 示例 2：

   输入：nums = [0,1,2,2,3,0,4,2], val = 2
   输出：5, nums = [0,1,4,0,3]
   解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。



### 8.1 解法一：双指针，val后移

当我们遇到 nums[i]=val 时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 1。

请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素。

```python
def removeElement_1(self, nums: List[int], val: int) -> int:
    """
    :description: 移除数组中的指定元素，双指针，val后移
    :param nums:
    :param val:
    :return:
    """
    i, count = 0, len(nums)
    while i < count:
        if nums[i] == val:
            nums[i] = nums[count-1]
            count -= 1
        else:
            i += 1

    return count
```



### 8.2 解法二：双指针，元素前移

双指针其实就是两个数，分别代表两个index，表示数组中第几个数的意思。比如这里，我们让a代表一个index，b代表一个index

然后我们让a一直往后移动，相当于nums[a]从数组第一个数遍历到最后一个数。当且仅当我们发现nums[a] != val 的时候，我们把这个数拷贝到 b 指向的位置，默认b是从0开始的，然后 b += 1指向下一个位置。

这样我们就保证了前b个数，就是我们要的结果。不重复的数。

```python
def removeElement_2(self, nums: List[int], val: int) -> int:
    """
    :description: 移除数组中的指定元素，双指针，元素前移
    :param nums:
    :param val:
    :return:
    """
    a, b = 0, 0

    while a < len(nums):
        if nums[a] != val:
            nums[b] = nums[a]
            b += 1
        a += 1

    return b
```

---



## 9 实现strStr() 

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

1. 示例 1：

   输入: haystack = "hello", needle = "ll"

   输出: 2

2. 示例 2:

   输入: haystack = "aaaaa", needle = "bba"

   输出: -1

说明:

1. 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。



### 9.1 解法一：字符串匹配

最直接的方法 - 沿着字符串逐步移动滑动窗口，将窗口内的子串与 needle 字符串比较。

```python
def strStr(self, haystack: str, needle: str) -> int:
    """
    :description: 实现strStr() 函数
    :param haystack:
    :param needle:
    :return:
    """
    if needle == "":
        return 0
    elif needle != "" and haystack == "":
        return -1
    else:
        len_1, len_2 = len(haystack), len(needle)
        for i in range(len_1):
            if haystack[i] == needle[0]:
                if i + len_2 <= len_1:
                    if haystack[i:i+len_2] == needle:
                        return i
        return -1
```

---



## 10 搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

1. 示例 1:

   输入: [1,3,5,6], 5

   输出: 2

2. 示例 2:

   输入: [1,3,5,6], 2

   输出: 1

3. 示例 3:

   输入: [1,3,5,6], 7

   输出: 4

4. 示例 4:

   输入: [1,3,5,6], 0

   输出: 0



### 10.1 解法一：暴力破解

依次查找，获取 nums 中第一个 大于等于 target 的下标

```python
def searchInsert(self, nums: List[int], target: int) -> int:
    """
    :description: 搜索插入位置
    :param nums:
    :param target:
    :return:
    """
    if not nums:
        return 0
    for i in range(0, len(nums)):
        if nums[i] >= target:
            return i
    return len(nums)
```



### 10.2 解法二：二分查找

假设题意是叫你在排序数组中寻找是否存在一个目标值，那么训练有素的读者肯定立马就能想到利用二分法在 O(logn) 的时间内找到是否存在目标值。但这题还多了个额外的条件，即如果不存在数组中的时候需要返回按顺序插入的位置，那我们还能用二分法么？答案是可以的，我们只需要稍作修改即可。

考虑这个插入的位置 pos，它成立的条件为：nums[pos−1] < target ≤ nums[pos]

其中 nums 代表排序数组。由于如果存在这个目标值，我们返回的索引也是 pos，因此我们可以将两个条件合并得出最后的目标：「在一个有序数组中找第一个大于等于 target 的下标」。

问题转化到这里，直接套用二分法即可，即不断用二分法逼近查找第一个大于等于 target 的下标 。下文给出的代码是笔者习惯的二分写法，ans 初值设置为数组长度可以省略边界条件的判断，因为存在一种情况是 target 大于数组中的所有数，此时需要插入到数组长度的位置。

```python
def searchInsert(self, nums: List[int], target: int) -> int:
    """
    :description: 搜索插入位置，二分查找
    :param nums:
    :param target:
    :return:
    """
    left, right = 0, len(nums)
    while left < right:
        mid = (left + right) // 2
        if nums[mid] < target:
            left = mid + 1
        else:
            right = mid
    return left
```

---



## 11 外观数列

给定一个正整数 n ，输出外观数列的第 n 项。

「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。

你可以将其视作是由递归公式定义的数字字符串序列：

- countAndSay(1) = "1"
- countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。

前五项如下：

1.     1
2.     11
3.     21
4.     1211
5.     111221
第一项是数字 1 
描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 "11"
描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 "21"
描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 "1211"
描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"

要描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。

例如，数字字符串 "3322251" 的描述如下图：

![img](算法练习.assets/countandsay.jpg)

1. 示例 1：

   输入：n = 1

   输出："1"，这是一个基本样例。

2. 示例 2：

   输入：n = 4

   输出："1211"

   解释：

   - countAndSay(1) = "1"
   - countAndSay(2) = 读 "1" = 一 个 1 = "11"
   - countAndSay(3) = 读 "11" = 二 个 1 = "21"
   - countAndSay(4) = 读 "21" = 一 个 2 + 一 个 1 = "12" + "11" = "1211"



### 11.1 解法：递归

利用递归，根据 前项 获取 后项

```python
def countAndSay(self, n: int) -> str:
    """
    :description: 输出外观数列的第 n 项
    :param n:
    :return:
    """
    if n == 1:
        return "1"
    else:
        str_num = "1"
        for i in range(n-1):
            str_num = Solution.description(str_num)
        return str_num

@classmethod
def description(cls, str_num: str) -> str:
    """
    方法用于：被 countAndSay 调用，描述num
    """
    val = str_num[0]
    return_str = ""
    j = 0
    for i in range(len(str_num)):
        if str_num[i] == val:
            j += 1
        else:
            return_str = return_str + str(j) + val
            val = str_num[i]
            j = 1

    # 解决 “11” 这种情况，避免循环结束后有数字的未被描述
    return_str = return_str + str(j) + val
    return return_str
```

---



## 12 最大子序和

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

1. 示例 1：

   输入：nums = [-2,1,-3,4,-1,2,1,-5,4]

   输出：6

   解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

2. 示例 2：

   输入：nums = [1]

   输出：1

3. 示例 3：

   输入：nums = [0]

   输出：0

4. 示例 4：

   输入：nums = [-1]

   输出：-1

5. 示例 5：

   输入：nums = [-100000]

   输出：-100000



### 12.1 解法一：动态规划

假设 nums 数组的长度是 n，下标从 0 到 n−1。

我们用 f(i) 代表以第 i 个数结尾的「连续子数组的最大和」，那么很显然我们要求的答案就是：
$$
max{f(i)}
$$
因此我们只需要求出每个位置的 f(i)，然后返回 f 数组中的最大值即可。那么我们如何求 f(i) 呢？我们可以考虑 nums[i] 单独成为一段还是加入 f(i−1) 对应的那一段，这取决于 nums[i] 和 f(i-1) + nums[i] 的大小，我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：
$$
f(i)=max[f(i−1)+nums[i],nums[i]]
$$
不难给出一个时间复杂度 O(n)、空间复杂度 O(n) 的实现，即用一个 f 数组来保存 f(i) 的值，用一个循环求出所有 f(i)。考虑到 f(i) 只和 f(i−1) 相关，于是我们可以只用一个变量 pre 来维护对于当前 f(i) 的 f(i−1) 的值是多少，从而让空间复杂度降低到 O(1)，这有点类似「滚动数组」的思想。

```python
def maxSubArray_1(self, nums: List[int]) -> int:
    """
    :description: 最大子序和，动态规划
    :param nums: list[int]
    :return: int
    """
    pre, max_ans = 0, nums[0]
    for i in nums:
        pre = max(pre+i, i)
        max_ans = max(max_ans, pre)

    return max_ans
```



### 12.2 解法二：分治

我们定义一个操作 **get(a, l, r)** 表示查询 **a** 序列 **[l，r]** 区间内的最大子段和，那么最终我们要求的答案就是 **get(nums, 0, nums.size() - 1)**。如何分治实现这个操作呢？

对于一个区间 **[l，r]**，我们取 
$$
m = ⌊ (l+r) / 2 ⌋
$$
对区间 **[l，m]** 和 **[m+1，r]** 分治求解。当递归逐层深入直到区间长度缩小为 **1** 的时候，递归「开始回升」。这个时候我们考虑如何通过 **[l，m]** 区间的信息和 **[m+1，r]** 区间的信息合并成区间 **[l，r]** 的信息。最关键的两个问题是：

- 我们要维护区间的哪些信息呢？
- 我们如何合并这些信息呢？

对于一个区间 **[l，r]**，我们可以维护四个量：

- **lSum** 表示 **[l，r]** 内以 **l** 为左端点的最大子段和
- **rSum** 表示 **[l，r]** 内以 **r** 为右端点的最大子段和 
- **mSum** 表示 **[l，r]** 内的最大子段和 
- **iSum** 表示 **[l，r]** 的区间和

以下简称 **[l，m]** 为 **[l，r]** 的「左子区间」，**[m+1，r]** 为 **[l，r]** 的「右子区间」。我们考虑如何维护这些量呢（如何通过左右子区间的信息合并得到 **[l，r]** 的信息）？对于长度为 **1** 的区间 **[i，i]**，四个量的值都和 **nums[ i ]** 相等。对于长度大于 **1** 的区间：

1. 首先最好维护的是 **iSum**，区间 **[l，r]** 的 **iSum** 就等于「左子区间」的 **iSum** 加上「右子区间」的 **iSum**。 
2. 对于 **[l，r]** 的 **lSum**，存在两种可能，它要么等于「左子区间」的 **lSum**，要么等于「左子区间」的 **iSum** 加上「右子区间」的 **lSum**，二者取大。 
3. 对于 **[l，r]** 的 **rSum**，同理，它要么等于「右子区间」的 **rSum**，要么等于「右子区间」的 **iSum** 加上「左子区间」的 **rSum**，二者取大。 
4. 当计算好上面的三个量之后，就很好计算 **[l，r]** 的 **mSum** 了。我们可以考虑 **[l，r]** 的 **mSum** 对应的区间是否跨越 **m** —— 它可能不跨越 **m**，也就是说 **[l，r]** 的 **mSum** 可能是「左子区间」的 **mSum** 和 「右子区间」的 **mSum** 中的一个；它也可能跨越 m，可能是「左子区间」的 **rSum** 和 「右子区间」的 **lSum** 求和。三者取大。

```python
def maxSubArray_2(self, nums: List[int]) -> int:
    """
    :description: 最大子序和，分治
    :param nums: list[int]
    :return: int
    """
    n = len(nums)
    # 递归终止条件
    if n == 1:
        return nums[0]
    else:
        # 递归计算左半边最大子序和
        max_left = self.maxSubArray(nums[0:len(nums) // 2])
        # 递归计算右半边最大子序和
        max_right = self.maxSubArray(nums[len(nums) // 2:len(nums)])

    # 计算中间的最大子序和，从右到左计算左边的最大子序和，从左到右计算右边的最大子序和，再相加
    max_l = nums[len(nums) // 2 - 1]
    tmp = 0
    for i in range(len(nums) // 2 - 1, -1, -1):
        tmp += nums[i]
        max_l = max(tmp, max_l)
    max_r = nums[len(nums) // 2]
    tmp = 0
    for i in range(len(nums) // 2, len(nums)):
        tmp += nums[i]
        max_r = max(tmp, max_r)
    # 返回三个中的最大值
    return max(max_right, max_left, max_l + max_r)
```

---



## 13 最后一个单词

给你一个字符串 s，由若干单词组成，单词之间用空格隔开。返回字符串中最后一个单词的长度。如果不存在最后一个单词，请返回 0 。

单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。

1. 示例 1：

   输入：s = "Hello World"

   输出：5

2. 示例 2：

   输入：s = " "

   输出：0

提示：

- 1 <= s.length <= 10^4
- s 仅有英文字母和空格 ' ' 组成



### 13.1 解法一

1. 从后往前过滤
2. 利用 length 记录长度，j 记录索引位置
3. 注意末尾的空格处理

```python
def lengthOfLastWord(self, s: str) -> int:
    """
    :description: 最后一个单词的长度
    :param s: str
    :return: int
    """
    length, j = 0, -1
    for i in range(len(s)):
        if s[j] == " ":
            if length == 0:
                j -= 1
            else:
                return length
        else:
            length += 1
            j -= 1
    return length
```

---



## 14 加一

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

1. 示例 1：

   输入：digits = [1,2,3]

   输出：[1,2,4]

   解释：输入数组表示数字 123。

2. 示例 2：

   输入：digits = [4,3,2,1]

   输出：[4,3,2,2]

   解释：输入数组表示数字 4321。

3. 示例 3：

   输入：digits = [0]

   输出：[1]

4. 示例4：

   输入：digits = [9]

   输出：[1, 0]



### 14.1 解法一

从后往前遍历

1. 当数字加一之后变为  9，则该位变为 0，其前一位 +1
2. 当第一位数字为 9，则该位变为 0，数组在索引为 0 的地方插入一位 1

```python
def plusOne(self, digits: List[int]) -> List[int]:
    """
    :description: 加一
    :param digits: list
    :return: list
    """
    for i in range(len(digits)-1, -1, -1):
        digits[i] += 1
        if digits[i] != 10:
            break
        else:
            digits[i] = 0
            if i == 0:
                digits.insert(0, 1)
    return digits
```

---



## 15 二进制求和

给你两个二进制字符串，返回它们的和（用二进制表示）。

输入为 非空 字符串且只包含数字 1 和 0。

1. 示例 1:

   输入: a = "11", b = "1"
   输出: "100"

2. 示例 2:

   输入: a = "1010", b = "1011"

   输出: "10101"



### 15.1 解法一

1. 补齐两个字符串，使得两个字符串的长度一致
2. 用 carry 记录 是否进位，res 记录 返回的字符串
3. 在计算过程中，将 字符 转换为 整数，计算结束后，再将 数字 转换为 字符

```python
def addBinary(self, a: str, b: str) -> str:
    """
    :description: 计算两个二进制数的和
    :param a:
    :param b:
    :return:
    """
    # 1. 补齐两个字符串，使得两个字符串一样长
    if len(a) < len(b):
        a = '0'*(len(b)-len(a))+a
    else:
        b = '0'*(len(a)-len(b))+b
    # carry 记录 是否进位，res 记录 返回的字符串
    carry = 0
    res = ''
    for i in range(len(a)-1, -1, -1):
        if int(a[i])+int(b[i])+carry >= 2:
            res = str(int(a[i])+int(b[i])+carry-2)+res
            carry = 1
        else:
            res = str(int(a[i])+int(b[i])+carry)+res
            carry = 0
    if carry == 1:
        res = '1'+res
    return res
```

---



## 16 x 的平方根

实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

1. 示例 1:

   输入: 4

   输出: 2

2. 示例 2:

   输入: 8

   输出: 2

   说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。



### 16.1 解法一：数学公式

利用 指数函数exp 和 对数函数 ln 代替平方根函数。

将 $\sqrt{x}$  写成 幂的形式：x^1/2^ ，在使用对数函数 e 进行换底，即可得到：
$$
\sqrt{x} = x^{1/2} = (e^{ln x})^{1/2} = e^{\frac{1}{2} lnx}
$$
注意：由于计算机无法存储浮点数的精确值，而指数函数和对数函数的参数和返回值均是浮点数，所以在运算过程中会存在误差。例如，当 x = 2147395600 时，$e^{\frac{1}{2}lnx}$ 的计算结果与正确值 46340 会相差 $10^{-11}$ ，这样对结果取整数部分时，会得到 46339 这个错误的结果

因此在获取结果的整数部分 ans 之后，要找出 ans 和 ans +1 哪个才是正确的答案

```python
def mySqrt(self, x: int) -> int:
    """
    :description: 求 x 的平方根
    :param x:
    :return:
    """
    if x == 0:
        return 0
    ans = int(math.exp(0.5 * math.log(x)))
    return ans + 1 if (ans + 1) ** 2 <= x else ans
```



### 16.2 解法二：二分查找

由于 $x$ 平方根的整数部分 ans 是满足 $k^2 \leq x$ 最大 k 值，因此我们可以对 k 进行二分查找，从而得到答案。

二分查找的下界为 0，上界可以粗略地设定为 x。在二分查找的每一步中，我们只需要比较中间元素 mid的平方与 x 的大小关系，并通过比较的结果调整上下界的范围。由于我们所有的运算都是整数运算，不会存在误差，因此在得到最终的答案 ans 后，也就不需要再去尝试 ans+1 了。

```python
def mySqrt_2(self, x: int) -> int:
    """
    :description: 求 x 的平方根，二分查找
    :param x:
    :return:
    """
    l, r, ans = 0, x, -1
    while l <= r:
        mid = (l+r) // 2
        if mid * mid <= x:
            ans = mid
            l = mid + 1
        else:
            r = mid-1
    return ans
```



### 16.3 解法三：牛顿迭代

牛顿迭代法是一种可以用来快速求解函数零点的方法。

为了叙述方便，我们用 C 表示待求出平方根的那个整数。显然，C 的平方根就是函数

$$
y = f(x) = x^2 - C
$$
的零点。

牛顿迭代法的本质是借助泰勒级数，从初始值开始快速向零点逼近。我们任取一个 $x_0$ 作为初始值，在每一步的迭代中，我们找到函数图像上的点 $(x_i, f(x_i))$，过该点作一条斜率为该点导数 $f'(x_i)$ 的直线，与横轴的交点记为 $x_{i+1}$ 。$x_{i+1}$ 相较于 $x_i$ 而言距离零点更近。在经过多次迭代后，我们就可以得到一个距离零点非常接近的交点。下图给出了从 $x_0$ 开始迭代两次，得到 $x_1$ 和 $x_2$ 的过程。

![fig1](算法练习.assets/69_fig1.png)

我们选择 $x_0 = C$ 作为初始值。

在每一步迭代中，我们通过当前的交点 $x_i$，找到函数图像上的点 $(x_i, x_i^2 - C)$，作一条斜率为 $f'(x_i) = 2x_i$ 的直线，直线的方程为：
$$
y_l = 2x_i(x - x_i) + x_i^2 - C \\= 2x_ix - (x_i^2 + C)
$$
与横轴的交点为方程 $2x_ix - (x_i^2 + C) = 0$ 的解，即为新的迭代结果 $x_{i+1}$ :
$$
x_{i+1} = \frac{1}{2}\left(x_i + \frac{C}{x_i}\right)
$$
在进行 k 次迭代后，$x_k$ 的值与真实的零点 $\sqrt{C}$  足够接近，即可作为答案。

细节：

1. 为什么选择 $x_0 = C$ 作为初始值？

   - 因为 $y = x^2 - C$ 有两个零点 $-\sqrt{C}$ 和 $\sqrt{C}$ 。 如果我们取的初始值较小，可能会迭代到 $-\sqrt{C}$ 这个零点，而我们希望找到的是 $\sqrt{C}$  这个零点。因此选择 $x_0 = C$ 作为初始值，每次迭代均有 $x_{i+1} < x_i$ ，零点 $\sqrt{C}$  在其左侧，所以我们一定会迭代到这个零点。

2. 迭代到何时才算结束？
   
- 每一次迭代后，我们都会距离零点更进一步，所以当相邻两次迭代得到的交点非常接近时，我们就可以断定，此时的结果已经足够我们得到答案了。一般来说，可以判断相邻两次迭代的结果的差值是否小于一个极小的非负数 $\epsilon$，其中 $ϵ$ 一般可以取 $10^{-6}$ 或 $10^{-7}$ 。
  
3. 如何通过迭代得到的近似零点得出最终的答案？

   - 由于 $y = f(x)$ 在 $[ C ,+∞]$ 上是凸函数（convex function）且恒大于等于零，那么只要我们选取的初始值 $x_0$  大于等于 $\sqrt{C}$  ，每次迭代得到的结果 $x_i$ 都会恒大于等于 $\sqrt{C}$  。因此只要 $\epsilon$ 选择地足够小，最终的结果 $x_k$ 只会稍稍大于真正的零点 $\sqrt{C}$ 。在题目给出的 32 位整数范围内，不会出现下面的情况：

     > 真正的零点为 $(n-1) / 2\epsilon$ ，其中 n 是一个正整数，而我们迭代得到的结果为 $(n-1) / 2\epsilon$ 在对结果保留整数部分后得到 n，但正确的结果为 n-1



```python
def mySqrt_3(self, x: int) -> int:
    """
    :description: 求 x 的平方根，牛顿迭代
    :param x:
    :return:
    """
    if x == 0:
        return 0
    c, x_0 = float(x), float(x)
    while True:
        x_i = 0.5 * (x_0 + c / x_0)
        if abs(x_0 - x_i) < 1e-7:
            break
        x_0 = x_i

    return int(x_0)
```

---



## 17 杨辉三角

给定一个非负整数 *numRows，*生成杨辉三角的前 *numRows* 行。

![img](算法练习.assets/PascalTriangleAnimated2.gif)

在杨辉三角中，每个数是它左上方和右上方的数的和。

1. 示例:

   输入: 5

   输出: [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]



### 17.1 解法

利用 杨辉三角 的规律

```python
def generate(self, numRows: int) -> List[List[int]]:
    """
    :description: 杨辉三角
    :param numRows:
    :return:
    """
    res_list = []
    pre_list = []
    for i in range(1, numRows+1):
        pre_list = Solution.generate_list(pre_list, i)
        res_list.append(pre_list)
    return res_list

@classmethod
def generate_list(cls, pre_list: List[int], length: int) -> List[int]:
    res_list = []
    if length == 1:
        res_list = [1]
    elif length == 2:
        res_list = [1, 1]
    else:
        res_list = [1, 1]
        for i in range(1, length-1):
            num = pre_list[i-1] + pre_list[i]
            res_list.insert(i, num)
    return res_list
```

---



## 18 杨辉三角 ||

给定一个非负索引 *k*，其中 *k* ≤ 33，返回杨辉三角的第 *k* 行。

优化你的算法到 *O*(*k*) 空间复杂度

1. 示例1

   输入：3

   输出：[1, 3, 3, 1]



### 18.1 解法一：动态数组

1. 新建两个数组
2. 一个存储前一行的值，一个生成该行的值

```python
def getRow(self, rowIndex: int) -> List[int]:
    """
    :description: 杨辉三角，获取指定行
    :param rowIndex: int
    :return: list[int]
    """
    pre_list = []
    for i in range(rowIndex+1):
        res_list = list()
        for j in range(0, i+1):
            if j == 0 or j == i:
                res_list.append(1)
            else:
                res_list.append(pre_list[j-1] + pre_list[j])
        pre_list = res_list
    return pre_list
```



### 18.2 解法二：反向求解

1. 只用一个数组
2. 当前行 第 i 项的计算只与 上一行第 i−1 项 及 第 i 项 有关。因此我们可以倒着计算当前行，这样计算到第 i 项时，第 i−1 项仍然是上一行的值。

```python
def getRow_2(self, rowIndex: int) -> List[int]:
    """
    :description: 杨辉三角，获取指定行
    :param rowIndex: int
    :return: list[int]
    """
    res_list = [1] * (rowIndex+1)
    for i in range(2, rowIndex+1):
        for j in range(i-1, 0, -1):
            res_list[j] = res_list[j] + res_list[j-1]
    return res_list
```

---



## 19 买卖股票的最佳时机

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

1. 示例 1：

   输入：[7,1,5,3,6,4]

   输出：5

   解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

2. 示例 2：

   输入：prices = [7,6,4,3,1]

   输出：0

   解释：在这种情况下, 没有交易完成, 所以最大利润为 0。



### 19.1 解法一：一次遍历

1. 一次遍历数组
2. 利用一个常量记录 当前的最小值，利用一个常量记录 当前的最大利益 
3. 随着遍历的进行，更新 最小值 和 最大利益

```python
def maxProfit(self, prices: List[int]) -> int:
    """
    :description: 买卖股票的最佳时机
    :param prices:
    :return:
    """
    i, profit = 0, 0
    for j in range(1, len(prices)):
        if prices[j] > prices[i]:
            if profit < prices[j] - prices[i]:
                profit = prices[j] - prices[i]
        else:
            i = j
    return profit
```

---



## 20 买卖股票的最佳时机 ||

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

1. 示例 1:

   输入: [7,1,5,3,6,4]

   输出: 7

   解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

2. 示例 2:

   输入: [1,2,3,4,5]

   输出: 4

   解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

3. 示例 3:

   输入: [7,6,4,3,1]

   输出: 0

   解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。



### 20.1 解法一：暴力破解

1. 以 低价格 买入
2. 当前的价格 大于 买入价格 且 大于 后一天的价格，卖出，获得利润最大

```python
def maxProfit(self, prices: List[int]) -> int:
    """
    :description: 买卖股票的最佳时机，进阶
    :param prices:
    :return:
    """
    if len(prices) == 0:
        return 0
    else:
        i, profit = 0, 0
        prices.append(0)
        for j in range(len(prices)):
            if prices[j] > prices[i] and prices[j] > prices[j+1]:
                profit = profit + prices[j] - prices[i]
                i = j+1
            if prices[j] < prices[i]:
                i = j
        return profit
```



### 20.2 解法二：贪心算法

1. 买卖策略：
   - 单独交易日： 设今天价格 $p_1$ 、明天价格 $p_2$ ，则今天买入、明天卖出可赚取金额: $p_2 - p_1$ ,负值代表亏损。
   - 连续上涨交易日： 设此上涨交易日股票价格分别为 $p_1, p_2, ... , p_n$ ，则第一天买最后一天卖收益最大，即 $p_n - p_1$ ，等价于每天都买卖，即 $p_n - p_1=(p_2 - p_1)+(p_3 - p_2)+...+(p_n - p_{n-1})$  。
   - 连续下降交易日： 则不买卖收益最大，即不会亏钱。

2. 算法流程：

   - 遍历整个股票交易日价格列表 price，策略是所有上涨交易日都买卖（赚到所有利润），所有下降交易日都不买卖（永不亏钱）。

   1. 设 tmp 为第 i-1 日买入与第 i 日卖出赚取的利润，即 tmp = prices[i] - prices[i - 1] ；
   2. 当该天利润为正 tmp > 0，则将利润加入总利润 profit；当利润为 0 或为负，则直接跳过
   3. 遍历完成后，返回总利润 profit。

```python
def maxProfit_2(self, prices: List[int]) -> int:
    """
    :description: 买卖股票的最佳时机，进阶，贪心算法
    :param prices:
    :return:
    """
    profit = 0
    for i in range(1, len(prices)):
        tmp = prices[i] - prices[i - 1]
        if tmp > 0:
            profit += tmp
    return profit
```

---



## 21 验证回文串

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

说明：本题中，我们将空字符串定义为有效的回文串。

1. 示例 1:

   输入: "A man, a plan, a canal: Panama"

   输出: true

2. 示例 2:

   输入: "race a car"

   输出: false

3. 示例3：

   输入：“   ”

   输出：true



### 21.1 解法一：双指针

1. 申明 i, j 两个指针，$i = 0，j = len(s) -1$
2. 两个指针单独向中间移动，其中跳过 非字母和数字 的字符，比较 i，j 指向的字符的 小写 是否相同
3. 当 i < j 时，跳出循环

```python
def isPalindrome(self, s: str) -> bool:
    """
    :description: 判断是否为 回文串
    :param s:
    :return:
    """
    i, j = 0, len(s)-1
    while i < j:
        # isalnum：库函数。判断传入的字符是否为字母或数字
        # 加入 i<j 的判定条件，防止出现 i或者j 溢出的情况
        # 例如：s = "    "
        while i < j and not s[i].isalnum():
            i += 1
        while i < j and not s[j].isalnum():
            j -= 1
        if i < j:
            if s[i].lower() != s[j].lower():
                return False
            i += 1
            j -= 1
    return True
```

---







# 中等算法分析

---

## 1 去除重复字母

给你一个字符串 `s` ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 **返回结果的字典序最小**（要求不能打乱其他字符的相对位置）。

示例 1：

- 输入：s = "bcabc"
- 输出："abc"

示例 2：

- 输入：s = "cbacdcbc"
- 输出："acdb"

提示：

1. 1 <= s.length <= 10^4
2. s 由小写英文字母组成

解释：字符串字典序

- 字典序遵循的是逐字符比较的方式，越靠左的字符越会被先比较;

- 逐字符比较过程中，一旦发现某一对被比较的字符之间不相等时，这一对字符的大小关系即为这一对字符串的大小关系："abc" < "abd"

- 逐字符比较过程中，一旦出现某一个字符串的所有字符都已经经过比较，而另一字符串还存在未被比较的字符时，较短的字符串更小。"abc" < "abcde"

- 如果所有字符串内的字符都被发现相等，则这两个字符串相等



### 1.1 解法一：贪心+单调栈

【字符串删除一个字符使其字典序最小的贪心策略】：

对于两个长度相同的字符串，最左边不同的字符决定了其字典序大小，例如，对于 A = xxaxxx，B = xxbxxx，如果 a > b， 则 A > B。

哪个字符串大取决于两个字符串中第1个对应不相等的字符，所以我们应该将最小的字符尽可能的放在前面。

对于一个字符串s[0...n-1]，如果必须删除1个字符使其删除后的字符串字典序最小

【删除策略】就是：

1. 从左往右找到第1个降序的位置i（s[i] > s[i+1]），删除s[i]；

   例："abcb"，应该删除 'c' 字符，这样删除一个字符后，字典序最小

2. 如果不存在降序位置，即字符串是升序的（[i+1]  >= [i]），删除末尾字符（字典序最大）；例："abcd"，应该删除 'd' 字符，这样删除一个字符后，字典序最小。

3. 如果删除k个字符使其删除后字典序最小，等同与先删除1个字符使其字典序最小，删除后的新字符串便形成了一个【子问题】，继续同样策略。

【算法思路】：

1. 维护一个词频表，表示每个字符后续可供选择的数量

2. 从左往右遍历每个字符，每次遍历，当前字符消耗1个（后续可供选择的数量减1）
   1. 如果当前字符后续已经没有可供选择数量了（<1），当前字符没得选了，只能选择要；
   2. 如果当前字符后续仍有数量（>=1），可以选择要当前字符，也可以选择不要，怎么选？

【一个字符要还是不要的选择策略】：

借助于上面描述的【字符串删除一个字符使其字典序最小的贪心策略】：

1. 如果当前保留的字符串的前一个字符字典序 > 当前字符，删除前一个字符，选择要当前字符；

2. 否则，选择删除当前字符，要前一个字符

【通过单调栈维护当前已经选择的字符】：

如果选择要一个字符，是否可以入栈，还需要判断之前是否已经选择过该字符：该字符是否存在单调栈中。

由于只有26个小写字母，可用一个bool数组即可代替Set结构。

```python
def removeDuplicateLetters(self, s: str) -> str:
    """
    :description: 移除重复字母
    :param s: str
    :return: str
    """
    # 计算每个字母在s中出现的次数，记录在cha_dict中：
    cha_dict = {}
    for cha in s:
        if cha not in cha_dict :
            cha_dict[cha] = 0
        cha_dict[cha] += 1

    # 建立一个栈tmp,保持栈是字典序最小：
    tmp = ['0']  # 为了防止出现tmp[-1]报错，左边加入最小哨兵
    for cha in s:  # 遍历字符串
        if cha not in tmp:  # 如果当前字符如果不在栈中，需要把它安排在合适的位置。
            while cha < tmp[-1]:
                if cha_dict[tmp[-1]] > 0:  # 当栈顶元素比当前字符大，且之后还会出现，则将其删除
                    del tmp[-1]
                else:  # 当栈顶元素不会再出现时，停止
                    break
            tmp.append(cha)
        # 如果当前字符如果已经在栈中，则它已经是在目前的最优位置了，不需要进行处理。
        cha_dict[cha] -= 1  # 当前元素的剩余数量-1
    ans = ''.join(tmp[1:])
    return ans
```

---

# 算法思路

---

## 1 分治

## 2 动态规划

## 3 贪心算法

## 4 时间空间复杂度

算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别。

那么我们应该如何去衡量不同算法之间的优劣呢？

主要还是从算法所占用的「时间」和「空间」两个维度去考量。

- 时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。
- 空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。

因此，评价一个算法的效率主要是看它的时间复杂度和空间复杂度情况。然而，有的时候时间和空间却又是「鱼和熊掌」，不可兼得的，那么我们就需要从中去取一个平衡点。

下面我来分别介绍一下「时间复杂度」和「空间复杂度」的计算方式。

### 4.1 时间复杂度

我们想要知道一个算法的「时间复杂度」，很多人首先想到的的方法就是把这个算法程序运行一遍，那么它所消耗的时间就自然而然知道了。

这种方式可以吗？当然可以，不过它也有很多弊端。这种方式非常容易受运行环境的影响，在性能高的机器上跑出来的结果与在性能低的机器上跑的结果相差会很大。而且对测试时使用的数据规模也有很大关系。再者，并我们在写算法的时候，还没有办法完整的去运行呢。

因此，另一种更为通用的方法就出来了：「 **大O符号表示法** 」，即 $T(n) = O(f(n))$

我们先来看个例子：

```c++
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

通过「 大O符号表示法 」，这段代码的时间复杂度为：O(n) ，为什么呢?

在 大O符号表示法中，时间复杂度的公式是： $T(n) = O( f(n) )$，其中 $f(n)$ 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：**算法的渐进时间复杂度**。

我们继续看上面的例子，假设每行代码的执行时间都是一样的，我们用 1 颗粒时间 来表示，那么这个例子的第一行耗时是 1 个颗粒时间，第三行的执行时间是 n 个颗粒时间，第四行的执行时间也是 n 个颗粒时间（第二行和第五行是符号，暂时忽略），那么总时间就是 1 颗粒时间 + n 颗粒时间 + n 颗粒时间 ，即 (1+2n)个颗粒时间，即： $T(n) = (1+2n)* 颗粒时间$ ，从这个结果可以看出，这个算法的耗时是随着 n 的变化而变化，因此，我们可以简化的将这个算法的时间复杂度表示为：$T(n) = O(n)$

为什么可以这么去简化呢，因为 大O符号表示法 并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。 

所以上面的例子中，如果 n 无限大的时候，$T(n) = time(1+2n)$ 中的常量 1 就没有意义了，倍数2 也意义不大。因此直接简化为 $T(n) = O(n)$ 就可以了。

常见的时间复杂度量级有：

- 常数阶O(1)
- 对数阶O(logN)
- 线性阶O(n)
- 线性对数阶O(nlogN)
- 平方阶O(n²)
- 立方阶O(n³)
- K次方阶O(n^k)
- 指数阶(2^n)

上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。

下面选取一些较为常用的来讲解一下（没有严格按照顺序）：

#### 4.1.1 **常数阶O(1)**

无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：

```c++
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。

#### 4.1.2 **线性阶O(n)**

这个在最开始的代码示例中就讲解过了，如：

```c++
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。

#### 4.1.3 **对数阶O(logN)**

还是先来看代码：

```c++
int i = 1;
while(i<n)
{
    i = i * 2;
}
```

从上面代码可以看到，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么   $x = log 2^n$ 也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：**O(logn)**

#### 4.1.4 **线性对数阶O(nlogN)**

线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。

就拿上面的代码加一点修改来举例：

```c++
for(m=1; m<n; m++)
{
    i = 1;
    while(i<n)
    {
        i = i * 2;
    }
}
```

#### 4.1.5 **平方阶O(n²)**

平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。
举例：

```c++
for(x=1; i<=n; x++)
{
   for(i=1; i<=n; i++)
    {
       j = i;
       j++;
    }
}
```

这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即 O(n²)。如果将其中一层循环的n改成m，即：

```c++
for(x=1; i<=m; x++)
{
   for(i=1; i<=n; i++)
    {
       j = i;
       j++;
    }
}
```

那它的时间复杂度就变成了 O(m*n)

#### 4.1.6 **立方阶O(n³)**、**K次方阶O(n^k)**

参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似。

除此之外，其实还有 平均时间复杂度、均摊时间复杂度、最坏时间复杂度、最好时间复杂度 的分析方法，有点复杂，这里就不展开了。

---



### 4.2 空间复杂度

既然时间复杂度不是用来计算程序具体耗时的，那么我也应该明白，空间复杂度也不是用来计算程序实际占用的空间的。

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。

空间复杂度比较常用的有：O(1)、O(n)、O(n²)，我们下面来看看：

#### 4.2.1 **空间复杂度 O(1)**

如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)
举例：

```c++
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)

#### 4.2.2 **空间复杂度 O(n)**

我们先看一个代码：

```c++
int[] m = new int[n]
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)