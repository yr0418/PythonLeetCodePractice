# 算法分析

---

## 1 两数之和

### 1.1 算法要求

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

你可以按任意顺序返回答案。

1. 示例 1：

   输入：nums = [2,7,11,15], target = 9

   输出：[0,1]

   解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

2. 示例 2：

   输入：nums = [3,2,4], target = 6

   输出：[1,2]

3. 示例 3：

   输入：nums = [3,3], target = 6

   输出：[0,1]
   
   

### 1.2 解法一：暴力破解

最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。

当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。

```python
def twoSum_1(self, nums: list[int], target: int) -> list[int]:
    """
    :type nums: List[int]
    :type target: int
    :rtype: List[int]
    :description：两数之和，暴力破解
    """
    for index1 in range(len(nums)):
        for index2 in range(index1+1, len(nums)):
            if nums[index1] + nums[index2] == target:
                return [index1, index2]
```



### 1.3 解法二：哈希表

注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。

使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N) 降低到 O(1)O(1)。

这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。

```python
def twoSum_2(self, nums: list[int], target: int) -> list[int]:
    """
    :type nums: List[int]
    :type target: int
    :rtype: List[int]
    :description：两数之和，哈希表
    """
    hashtable = dict()
    for i, num in enumerate(nums):  # enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标
        if target - num in hashtable:  # key in dict：判断指定的键是否在字典中
            return [hashtable[target - num], i]
        hashtable[nums[i]] = i  # nums 中的数据进字典。nums[i] 为键，i为值
    return []
```

---



## 2 整数反转

### 2.1 算法要求

给你一个 32 位的有符号整数 x ，返回 x 中每位上的数字反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−2^31,  2^31 − 1] ，就返回 0。

假设环境不允许存储 64 位整数（有符号或无符号）。

1. 示例 1：

   输入：x = 123

   输出：321

2. 示例 2：

   输入：x = -123

   输出：-321

3. 示例 3：

   输入：x = 120

   输出：21

4. 示例 4：

   输入：x = 0

   输出：0



### 2.2 解法一：弹出和推入数字 & 溢出前进行检查

我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。

反转整数的方法可以与反转字符串进行类比。

我们想重复 “弹出”  xx 的最后一位数字，并将它 “推入” 到 rev 的后面。最后，rev 将与 xx 相反。

要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。

```python
# pop operation:
pop = x % 10;
x /= 10;

# push operation:
temp = rev * 10 + pop;
rev = temp;
```

但是，这种方法很危险，因为当 temp = rev⋅10+pop 时会导致溢出。幸运的是，事先检查这个语句是否会导致溢出很容易。在Python中可以设定 rev 的边界值，确定 rev 在边界之中即可

```python
def reverse(self, x: int) -> int:
    """
    :type x: int
    :rtype: int
    :description：整数反转
    """
    y, result = abs(x), 0 # 将 x 取绝对值，方便处理 负数，具体原因见 算法练习--2.3
    while y != 0:
        pop = y % 10
        y = y // 10 # 求余数，向下取整，单纯的 / 号，会使得 int 变成 float 类型
        result = result * 10 + pop
        #  边界的表示方法： boundry = (1<<31) -1 if x>0 else 1<<31。 result > boundry 即表示超过边界
        if -pow(2, 31) <= result <= pow(2, 31) - 1:
            continue
        else:
            return 0
    return result if x > 0 else -result
```



### 2.3 Python中负数取余的问题

C语言、java 这些是向0取值，-10 对 3 取余 得 -3 余 -1 ，

python 是向负无穷取值，-10 对 3 取余 得 -4 余 2.

在本题中，-123 % 10 = 7，因为 -123 对 10 取余 得 -13 余 7

---



## 3 回文数

### 3.1 算法要求

给你一个整数 x ，如果 x 是一个回文整数，返回 ture ；否则，返回 false 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。

1. 示例 1：

   输入：x = 121

   输出：true

2. 示例 2：

   输入：x = -121

   输出：false

   解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

3. 示例 3：

   输入：x = 10

   输出：false

   解释：从右向左读, 为 01 。因此它不是一个回文数。

4. 示例 4：

   输入：x = -101

   输出：false

提示：-2^31 <= x <= 2^31 - 1。



### 3.2 解法一：借助字符串

暴力破解，时间长，内存消耗大

```python
def is_palindrome(self, x) -> bool:
    """
    :type x: int
    :rtype: bool
    :description: 回文数判断，借助字符串
    """
    return str(x) == str(x)[::-1]
```

**注意：字符串截取**

```python
s = 'abcdefg'
a = s[0]  # 下标为 0 的字符
b = s[1]  # 下标为 1 的字符
c = s[0: ]  # 从下标为 0 的位置开始截取，直到最后一个字符
d = s[1:4]  # 从下标为 1 的位置开始截取，直到下标为 4 的字符，但不包含第四个字符
e = s * 2  # *号，重复字符串 s 两次，赋值给 e
f = s + 'abc'  # 字符串的加法运算，s 的末尾 加上 'abc'
g = s[1:4:2]  # 在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串

# 利用负数下标截取字符串
x = s[-4:-1] # 从下标为 -4 开始时截取 至 下标为 -1 前的字符：def
x = s[-1:-4] # 截取失败，截取字符串默认从前往后截取，s[4:1] 同样截取失败

# 注意特殊情况
x = s[4:1:-1] # 截取成功，x = edc。即逆置截取字符串，从索引为 4 开始，截取至 索引为 1，不包括索引1. 
x = s[::-1] # 逆置截取全部字符
x = s[::] # 截取全部字符串
```



### 3.3 解法二：反转一半的数字

**思路：**

第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。但是，如果反转后的数字大于 int.MAX，我们将遇到整数溢出问题。

按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。

例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们得知数字 1221 是回文。

**算法：**

首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。

除了 0 以外，所有个位是 0 的数字不可能是回文，因为最高位不等于 0。所以我们可以对所有大于 0 且个位是 0 的数字返回 false。

现在，让我们来考虑如何反转后半部分的数字：

对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。

现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？

由于整个过程我们不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着我们已经处理了一半位数的数字了。

![fig1](算法练习.assets/9_fig1.png)

```python
def is_palindrome_2(self, x) -> bool:
    """
    :type x: int
    :rtype: bool
    :description: 回文数判断，反转一半的数字
    """
    if x < 0 or (x % 10 == 0 and x != 0):
        return False
    reverted_number = 0
    while x > reverted_number:
        reverted_number = reverted_number * 10 + x % 10
        x //= 10
    return x == reverted_number or x == reverted_number // 10
```

---



## 4 罗马数

### 4.1 算法描述

罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

| 字符 | 数值 |
| :--: | :--: |
|  I   |  1   |
|  V   |  5   |
|  X   |  10  |
|  L   |  50  |
|  C   | 100  |
|  D   | 500  |
|  M   | 1000 |

例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

1. I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
2. X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
3. C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。

1. 示例 1:

   输入: "III"

   输出: 3

2. 示例 2:

   输入: "IV"

   输出: 4

3. 示例 3:

   输入: "IX"

   输出: 9

4. 示例 4:

   输入: "LVIII"

   输出: 58

   解释: L = 50, V= 5, III = 3.

5. 示例 5:

   输入: "MCMXCIV"

   输出: 1994

   解释: M = 1000, CM = 900, XC = 90, IV = 4.

**提示：**

1. 1 <= s.length <= 15
2. s 仅含字符 ('I', 'V', 'X', 'L', 'C', 'D', 'M')
3. 题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内
4. 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。
5. IC 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。
6. 关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。



### 4.2 解法一：暴力破解，字符串匹配

字符串依次匹配

```python
def romanToInt(self, s: str) -> int:
    """
    :type s: str
    :rtype: int
    :description: 罗马数
    """
    i, num = 0, 0
    while i < len(s):
        if s[i] == 'M':
            num = num + 1000
            i = i + 1
        elif s[i] == 'D':
            num = num + 500
            i = i + 1
        elif s[i] == 'C':
            if i == len(s) - 1:
                num = num + 100
                i = i + 1
            elif s[i + 1] == 'D':
                num = num + 400
                i = i + 2
            elif s[i + 1] == 'M':
                num = num + 900
                i = i + 2
            else:
                num = num + 100
                i = i + 1
        elif s[i] == 'L':
            num = num + 50
            i = i + 1
        elif s[i] == 'X':
            if i == len(s) - 1:
                num = num + 10
                i = i + 1
            elif s[i+1] == 'L':
                num = num + 40
                i = i + 2
            elif s[i+1] == 'C':
                num = num + 90
                i = i + 2
            else:
                num = num + 10
                i = i + 1
        elif s[i] == 'V':
            num = num + 5
            i = i + 1
        elif s[i] == 'I':
            if i == len(s)-1:
                num = num + 1
                i = i + 1
            elif s[i+1] == 'V':
                num = num + 4
                i = i + 2
            elif s[i+1] == 'X':
                num = num + 9
                i = i + 2
            else:
                num = num + 1
                i = i + 1
    return num
```



### 4.3 解法二：罗马数规律

按照题目的描述，可以总结如下规则：

1. 罗马数字由 I, V, X, L, C, D, M 构成；
2. 当小值在大值的左边，则减小值，如 IV=5-1=4；
3. 当小值在大值的右边，则加小值，如 VI=5+1=6；
4. 由上可知，右值永远为正，因此最后一位必然为正。

在代码实现上，可以往后看多一位，对比当前位与后一位的大小关系，从而确定当前位是加还是减法。当没有下一位时，做加法即可。

也可保留当前位的值，当遍历到下一位的时，对比保留值与遍历位的大小关系，再确定保留值为加还是减。最后一位做加法即可。

```python
# 自定义 get_value 函数
def romanToInt_2(self, s: str) -> int:
    """
    :type s: str
    :rtype: int
    :description: 罗马数，罗马数规律
    """
    prenum, num, sum = Solution.get_num(s[0]), 0, 0
    for i in range(1, len(s)):
        num = Solution.get_num(s[i])
        if prenum < num:
            sum = sum - prenum
        else:
            sum = sum + prenum
        prenum = num
    return sum + prenum

@classmethod  # 加入 @classmethod 注释，方便直接调用该方法
def get_num(cls, s: str) -> int:
    num = 0
    if s == 'M':
        num = 1000
    elif s == 'D':
        num = 500
    elif s == 'C':
        num = 100
    elif s == 'L':
        num = 50
    elif s == 'X':
        num = 10
    elif s == 'V':
        num = 5
    elif s == 'I':
        num = 1
    return num
 
# 利用哈希表取值
def romanToInt_3(self, s: str) -> int:
    """
    :type s: str
    :rtype: int
    :description: 罗马数，罗马数规律，利用哈希表取值
    """
    roman_int = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    int = 0
    for index in range(len(s)-1):
        if roman_int[s[index]] < roman_int[s[index+1]]:
            int -= roman_int[s[index]]
        else:
            int += roman_int[s[index]]
    return int + roman_int[s[-1]]
```



### 4.4 解法三：利用字典进行字符串匹配

构建一个字典记录所有罗马数字子串，注意长度为2的子串记录的值是（实际值 - 子串内左边罗马数字代表的数值）

这样一来，遍历整个 ss 的时候判断当前位置和前一个位置的两个字符组成的字符串是否在字典内，如果在就记录值，不在就说明当前位置不存在小数字在前面的情况，直接记录当前位置字符对应值

```python
def romanToInt_4(self, s: str) -> int:
    """
    :type s: str
    :rtype: int
    :description: 罗马数，利用字典进行字符串匹配
    """
    # 注意在字典中 IX = 8，因为对于 XIX，第一次str1 = XI，匹配到 I，则 result+1，第二次匹配到 IX，则result + 8，两次合起来实现 IX = 9
    d = {'I': 1, 'IV': 3, 'V': 5, 'IX': 8, 'X': 10, 'XL': 30, 'L': 50, 'XC': 80, 'C': 100, 'CD': 300, 'D': 500, 'CM': 800, 'M': 1000}
    result = 0
    for i, n in enumerate(s):
        str1 = s[max(i - 1, 0):i + 1]  # 作者解析中的2就是用这行代码实现的
        if str1 in d:
            result += d.get(str1)
        else:
            result += d[n]
    return result
```

---



## 5 最长公共前缀

### 5.1 算法描述

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

1. 示例 1：

   输入：strs = ["flower","flow","flight"]

   输出："fl"

2. 示例 2：

   输入：strs = ["dog","racecar","car"]

   输出：""

   解释：输入不存在公共前缀。

提示：

- 0 <= strs.length <= 200
- 0 <= strs[i].length <= 200
- strs[i] 仅由小写英文字母组成



### 5.2 解法一：字符串截取，适用于Python

```python
def longestCommonPrefix_1(self, strs: List[str]) -> str:
    """
    :description: 最长公共前缀，字符串截取
    """
    if not strs:
        return ""
    else:
        str_1 = strs[0]
        for i in range(len(str_1)):
            for j in range(len(strs)):
                # 正常情况
                if strs[j][:i+1] != str_1[:i+1]:
                    return str_1[:i]
                else:
                    continue
        # 解决异常情况，当strs里的值都是相同的时候
        return str_1
 
def longestCommonPrefix_2(self, strs: List[str]) -> str:
    """
    :description: 最长公共前缀，字符串匹配，算法优化
    """
    if not strs:
        return ""
    # 利用 min 和 max 取 strs 中最长和最短的字符串
    str0 = min(strs)
    str1 = max(strs)
    for i in range(len(str0)):
        if str0[i] != str1[i]:
            return str0[:i]
    return str0
```



### 5.3 解法二：通用解法，纵向扫描

纵向扫描时，从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，当前列之前的部分为最长公共前缀。

![fig2](算法练习.assets/14_fig2.png)

```python
def longestCommonPrefix_2(self, strs: List[str]) -> str:
    """
    :description: 最长公共前缀，字符串匹配，算法优化
    """
    if not strs:
        return ""
    length, count = len(strs[0]), len(strs)
    for i in range(length):
        c = strs[0][i]
        if any(i == len(strs[j]) or strs[j][i] != c for j in range(1, count)):
            return strs[0][:i]

    return strs[0]
```

---



## 6 有效的括号

### 6.1 算法描述

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。

1. 示例 1：

   输入：s = "()"

   输出：true

2. 示例 2：

   输入：s = "()[]{}"

   输出：true

3. 示例 3：

   输入：s = "(]"

   输出：false

4. 示例 4：

   输入：s = "([)]"

   输出：false

5. 示例 5：

   输入：s = "{[]}"

   输出：true

提示：

- 1 <= s.length <= 10^4
- s 仅由括号 '()[]{}' 组成



### 6.2 解法一：标准解法，利用栈

**注意：**

Python中涉及字符串的匹配时可以利用字典简化代码

```python
def isValid_2(self, s: str) -> bool:
    """
    :description: 有效的括号，利用字典匹配
    :param s: 只含括号的字符串
    :return: bool
    """
    if len(s) % 2 == 1:
        return False
    else:
        pairs = {")": "(", "]": "[", "}": "{"}
        list_1 = []
        for ch in s:
            if ch in pairs:
                if not list_1 or list_1[-1] != pairs[ch]:
                    return False
                list_1.pop()
            else:
                list_1.append(ch)
        return not list_1
```

---



